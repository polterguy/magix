
inspect=>@"documentation for Magix.execute

contains the documentation for all active events in the 
Magix.execute assembly"


magix.execute.add-dox=>@"adds a node to another node

creates a deep copy of the node returned by the expression in the [value] node, and appends 
it into the expression found in [add].  if no [value] node is given, then all children of 
[add] will be added.  the [add] node must have en expression returning a node lists

if a [values] node is given then only the children of the node returned by the expression in [values] 
will be added to the nodes found in the expression of [add].  if a [value] node exists, with an 
expression returning a node list, then the entire node tree will be copied, with its children, 
including the node returned from [value] itself

if a [value] node exists, and it is a contant, or an expression returning anything but a node list, 
then a node with the name returned from the constant or expression of the [value] node will be 
added to the node list of the expression returned by [add].  in this case, one node will be added 
to the node list in the [add] expression, with the name of the [value] node's value.   if you supply 
a [value] node, who's value is not a node list, you can optionally also supply an additional [value] 
node as a child of the first [value] node, who's expression or constant value will become the value 
of the node added to the [add] node's collection.  if you supply the second [value] node, you can 
addditionally supply this node's value as a formatting expression, using {0} and {1} to de-reference 
items being children of the second [value] node, to format strings

thread safe"

magix.execute.add-sample
  _copy
  _data
    children=>original
    children1=>will be copied
      item1=>will be copied too
      item2=>will also be copied
  add=>[_copy]
    values=>[_data]


magix.execute.node-2-code-dox=>@"transforms a node to text

will transform the [node] node to code syntax, and return it in [code].  [node] can either have 
its nodes as the value of the [node], as children nodes directly underneath the [node] node, or 
as an expression returned from the node node's value.  the code returned will be the textual 
representation of the original tree hierarchy with hyperlisp syntax.  two spaces opens up a child 
collection.  => separates name and value of node, etc

code returned might also contain type information for types of int, decimal, datetime and bool.  
if [remove-root] is true, then the root node will be removed, and not be a part of the code 
returned

thread safe"

magix.execute.node-2-code-sample
  node-2-code
    node
      some-node
        a-child=>howdy
        another-child=>hello
      another-node=>yo!


magix.execute.code-2-node-dox=>@"transforms hyperlisp text code to nodes

will transform the [code] node to a node tree

the code will be returned in [node] as a node structure.  the code will 
be parsed as hyperlisp code, meaning two indentations opens up a new 
children collection, =>assigns a value to the node with the name to the 
left of the => operator, etc

thread safe"

magix.execute.code-2-node-sample
  code-2-node
    code=>@"
code
  goes
    here"


magix.execute.debug-dox=>@"shows a debug dialog of the node stack

shows the entire stack of hyperlisp code in a modal message box.  
alternatively, you can submit an expression, pointing to a node list, 
to show only a subsection of the tree

not thread safe"

magix.execute.debug-sample
  magix.execute
    set=>[@][foo.bar].value
      value=>true
  debug=>[magix.execute]


magix.execute.application-startup-dox=>@"maps serialized active events

called during startup of application 
to make sure our active events, which are dynamically tied towards serialized hyper 
lisp blocks of code, are being correctly re-mapped"


magix.execute.event-dox=>@"creates a new active event

overrides the active event in [name] with the hyperlisp code in the [code] expression.  
these types of active events can take and return parameters.  if you wish to pass in or 
retrieve parameters, then as you invoke the function, just append your parameters 
underneath the function invocation, and they will be passed into the function, where 
they will be accessible underneath the [$] node, appended as the last parts of your code 
block, into your function invocation.  from outside of the active event itself, you can 
access these parameters directly underneath the active event itself

any existing event with the name from the [event] node's value will be deleted, if you 
pass in no [code] block.  if you set the [remotable] node to true, then the active event 
will be possible to invoke by remote servers, and marked as open.  if you set [persist] 
to false, then the active event will not be serialized into the data storage, meaning it 
will only last as long as the application is not restarted.  this is useful for active 
events whom are created for instance during the startup of your application, since it 
will save time, since they will anyway be overwritten the next time your application 
restarts

if you add an [inspect] node, then this will become the inspect value of the active event.  
[inspect] can be either an expression or a constant, and can also contain formatting 
expressions, such as {0} and {1}, referencing values beneath the inspect node

[name] can be either an expression, or a constant

thread safe"

magix.execute.event-sample
  event
    name=>foo.bar
    remotable=(bool)>False
    persist=(bool)>False
    code
      _data=>thomas
      _backup=>thomas
      if=>equals
        lhs=>[_data].value
        rhs=>[_backup].value
        code
          set=>[$][output].value
            value=>return-value
          set=>[/][magix.viewport.show-message][message].value
            value=>[$][input].value
      magix.viewport.show-message
  foo.bar
    input=>hello world 2.0
  event
    name=>foo.bar


magix.execute._active-event-2-code-callback-dox=>@"maps dynamic active events

maps dynamic active events towards their stored code.  is the main entry point for 
dynamically created active events, and will map the active event towards the actual 
code intended to be executed"


magix.execute._active-event-2-code-callback-dynamic-dox=>@"dynamically created active event

dynamically created active event, created with the [event] keyword.  
thread safety is dependent upon the active events raised internally 
within the active event"


magix.execute.list-events-dox=>@"lists all active events in the system

returns all active events within the system.  add [all], [open], [remoted], 
[overridden] or [begins-with] to filter the events returned

active events are returned in [events].  list-events will not return unit 
tests and active events starting with '_' if [all] is false.  if [all], 
[open], [remoted] or [overridden] is defined, it will return all events 
fullfilling criteria, regardless of whether or not they are private events, 
tests or don't match the [begins-with] parameter

thread safe"

magix.execute.list-events-sample
  list-events
    begins-with=>magix.execute


magix.execute.try-dox=>@"creates a try block to handle exceptions

use the [try] keyword to create a block of [code], which will execute 
your [catch] execution block of code, if an exception is thrown, inside 
your [code] execution block

this exception handler will be invoked, even if an exception occurs any 
place underneath your try code block, deep within your logic.  you can 
handle exceptions being raised in sub-functions, recursively invoked 
active events, or natively thrown exceptions this way

if an exception is thrown, you can access the description of the 
exception in the [exception] node underneath your catch statement.  you 
can also add a [finally] piece of code block underneath the [try], which will 
always be executed, regardless of whether or not an exception was thrown

thread safe"

magix.execute.try-sample
  try
    code
      throw=>to try or not to try
      magix.viewport.show-message
        message=>crap, didn't work
    catch
      set=>[@][magix.viewport.show-message][message].value
        value=>[@][exception].value
      magix.viewport.show-message


magix.execute.throw-dox=>@"throws an exception

throws an exception, which will stop the entire current execution, and 
halt back to the previous catch, in the stack of active events.  [exception] 
in [catch] becomes the value of the [throw] node, or the exception message.  
use throw together with [try] to handle errors

to create handlers that handles all exceptions, you can create an active event 
who's name is 'magix.execute.exception'

thread safe"

magix.execute.throw-sample
  try
    code
      throw=>some exception error message
    catch
      set=>[@][magix.viewport.show-message][message].value
        value=>[@][exception].value
      magix.viewport.show-message


magix.execute.using-dox=>@"changes the default namespace

changes the default namespace for the current scope.  this allows you to raise 
active events which you normally would have to raise with a period in their 
name, without the period, which allows active events which normally cannot 
access the entire execution tree, to access the entire code tree

thread safe"

magix.execute.using-sample
  using=>magix.math
    add
      =(int)>4
      =(int)>1
  using=>magix.viewport
    show-message
      message=>[using][add].value


magix.execute.sandbox-dox=>@"restricts the active events possible to raise

changes the execution engine, making sure only keywords and active events within 
[whitelist] are legal keywords

this is a useful feature to prevent external sources, or untrusted scripts, to 
execute malicious code.  all keywords and active events which are not declared in 
the [whitelist] parameter, are illegal to executed as long as the instruction 
pointer is within the scope of the [code] block, which declares the block of code that 
is to be sandboxed

thread safe"

magix.execute.sandbox-sample
  sandbox
    whitelist
      foo
    code
      bar=>throws exception


magix.execute.execute-dox=>@"main hyperlisp execution entry point

executes the incoming parameters as hyperlisp, meaning it will raise everything 
containing a period ('.') as an active event, while everything not starting with 
an underscore ('_'), and not containing a period (.), will be assumed to be a 
hyperlisp keyword, and have the current namespace prepended in front of it, before 
it is raised as an active event.  the default namespace is 'magix.execute', but this 
can be overridden with the [using] keyword

a hyperlisp keyword will have access to the entire data tree, while a normal active 
event can only access the parts of the tree from underneath its own node

you can change the namespace prepended in front of all hyperlisp keywords with the 
keyword [using], and such modify the namespace prepended in front of every hyperlisp 
keyword to whatever you choose for yourself, and in such a way, create hyperlisp 
keywords of existing active events, from any namespace you choose

you can alternatively pass in an expression as the value of [execute] which will 
execute that expression as hyperlisp.  if you do, then your expression must return 
a node list, and you can not use the fully qualified version of magix.execute.execute, 
but must use only [execute] as your keyword

if you fully declare your execute keyword, by appending the magix. namespace in 
front of it, like [magix.execute], then the hyperlisp code beneath [magix.execute] 
will be executed such that it does not have acccess to the code outside of itself.  
this is useful to make sure code does not have side-effects on other parts of your 
code

thread safe"

magix.execute.execute-sample
  _data
    value=>thomas
  execute
    if=>equals
      lhs=>[_data][value].value
      rhs=>thomas
      code
        magix.execute
          _data=>hi thomas
          execute=>[_exe-node]
          _exe-node
            using=>magix.viewport
              show-message
                message=>[_data].value
    else
      magix.viewport.show-message
        message=>hi stranger


magix.execute.for-each-dox=>@"iterates through a node list

loops through all the nodes in the given node-list expression, 
setting the data-pointer to the currently processed item

your code will execute once for every single node you have in 
your return expression.  use the [.] expression to de-reference 
the currently iterated node

for-each executes immutable, meaning it will not modify its child 
nodes after it is done executing, and every iteration of the loop 
will execute on a 'virgin' version of its code.  this means that 
the code it executes will be reset back to what it originally was 
for every single iteration of the loop

thread safe"

magix.execute.for-each-sample
  _data
    items
      message1=>howdy world 1.0
      message2=>howdy world 2.0
      message3=>howdy world 3.0
      message4=>howdy world 4.0
      message5=>howdy world 5.0
      message6=>howdy world 6.0
      message7=>howdy world 7.0
  for-each=>[_data][items]
    set=>[@][magix.viewport.show-message][message].value
      value=>[.].value


magix.execute.if-dox=>@"checks statement and executes code if true

executes the [code] block of nodes as an execution block, but only if 
the [if] statement returns true

pair your [if] statements together with [else-if] and [else] to create 
branching logic and control of flow within your program.  if an [if]
statement returns true, then no paired [else-if] or [else] statements 
will be executed

the operator used to compare the [lhs] and the [rhs] nodes must be 
defined using the value of the [if] node.  legal values for the 
operator is 'exist', 'not-exist', 'equals', 'not-equals', 
'less-than', 'more-than', 'less-than-equals' and 'more-than-equals'

[lhs] means 'left-hand-side'.  the lhs node is to the left of the 
operator.  [rhs] means 'right-hand-side', and is conceptually to the 
right of the operator.  this means that if you have an lhs value of 
'x' and an rhs value of 'y' and your operator is 'equals', then the 
full comparison statement becomes 'if x equals y'.  if you have an 
operator of 'more-than', and an [lhs] of 5 and an [rhs] of 4, then 
the full statement becomes 'if 5 is more-than 4', which of course 
will evaluate to true.  both [lhs] and [rhs] can be either constants 
or expressions

depending upon the comparison operator you use, the rhs node might 
not be necessary.  for instance, 'exist' does not need a right-hand-side, 
or an rhs node, simply since it only checks for the existence of one 
specific node, value or name

you can optionally also supply as many [or] and/or [and] nodes beneath 
your [if] node.  if you do, then these are additional statements that 
needs to return true to make the if statement become true as a whole.  
if you supply an or and/or an and statement beneath your if or else-if, 
then you must add up a comparison operator as the value of your [and] 
and [or] statement, and another pair of [lhs] and [rhs] nodes beneath 
your and and or statements

the engine will convert automatically between int, decimal, date and 
bool, or resort to string if no conversion is possible.  you can compare 
two node trees in [lhs] and [rhs], which means that the node trees will 
be compared deeply, comparing their name, value and children for equality

thread safe"

magix.execute.if-sample
  _data
    item=>cache-object
    cache
  if=>not-equals
    lhs=>[_data][item].value
    rhs=>[_data][1].name
    and=>not-exist
      lhs=>[_data].value
    code
      magix.viewport.show-message
        message=>not equal, and no _data value


magix.execute.else-if-dox=>@"checks statement and executes code if true

executes the [code] block of nodes as an execution block, but only if 
the [else-if] statement returns true, and no previous [if] or [else-if] 
have been executed

pair your [else-if] statements together with [if] and [else] to create 
branching logic and control of flow within your program.  if an [if]
statement returns true, then no paired [else-if] or [else] statements 
will be executed.  the else-if statement can only follow directly after 
an [if] statement, or another [else-if] statement

the operator used to compare the [lhs] and the [rhs] nodes must be 
defined using the value of the [else-if] node.  legal values for the 
operator is 'exist', 'not-exist', 'equals', 'not-equals', 
'less-than', 'more-than', 'less-than-equals' and 'more-than-equals'

[lhs] means 'left-hand-side'.  the lhs node is to the left of the 
operator.  [rhs] means 'right-hand-side', and is conceptually to the 
right of the operator.  this means that if you have an lhs value of 
'x' and an rhs value of 'y' and your operator is 'equals', then the 
full comparison statement becomes 'if x equals y'.  if you have an 
operator of 'more-than', and an [lhs] of 5 and an [rhs] of 4, then 
the full statement becomes 'if 5 is more-than 4', which of course 
will evaluate to true.  both [lhs] and [rhs] can be either constants 
or expressions

depending upon the comparison operator you use, the rhs node might 
not be necessary.  for instance, 'exist' does not need a right-hand-side, 
or an rhs node, simply since it only checks for the existence of one 
specific node, value or name

you can optionally also supply as many [or] and/or [and] nodes beneath 
your [else-if] node.  if you do, then these are additional statements that 
needs to return true to make the if statement become true as a whole.  
if you supply an or and/or an and statement beneath your if or else-if, 
then you must add up a comparison operator as the value of your [and] 
and [or] statement, and another pair of [lhs] and [rhs] nodes beneath 
your and and or statements

the engine will convert automatically between int, decimal, date and 
bool, or resort to string if no conversion is possible.  you can compare 
two node trees in [lhs] and [rhs], which means that the node trees will 
be compared deeply, comparing their name, value and children for equality

thread safe"

magix.execute.else-if-sample
  _data
    node
  if=>exist
    lhs=>[_data][node].value
    code
      magix.viewport.show-message
        message=>darn it
  else-if=>exist
    lhs=>[_data][node]
    code
      magix.viewport.show-message
        message=>puuh


magix.execute.else-dox=>@"default execution of if and else-if

executes the underlaying code block, but only if no paired [if] 
or [else-if] statement has been executed.  pair up your [else] 
with [if] and [else-if] to create branching in your code

thread safe"

magix.execute.else-sample
  if=>exist
    lhs=>[_not-existing-node]
    code
      magix.viewport.show-message
        message=>ohh crap
  else
    magix.viewport.show-message
      message=>yup, still sane


magix.execute.index-of-dox=>@"returns index of a string

returns the index of all occurences of the [what] constant 
or expression as nodes containing the integer value of where match 
was found underneath the [result] return node

if [case] equals false, the search will ignore casing of text when 
looking for a match

thread safe"

magix.execute.index-of-sample
  _data=>this will return the position of all 'r' characters in string
  index-of=>[_data].value
    what=>r


magix.execute.iterate-dox=>@"iterates a node tree

loops through all the nodes in the given node-list expression, flattening 
the hierarchy, setting the data-pointer to the currently processed item

notice how this differs in regards to the [for-each] keyword.  the for-each 
only iterates over the children of the nodes referenced in its expression.  
while the [iterate] keyword will iterate the entire tree hierarchy, including 
all children of the nodes in the expression, their children, and their 
children's children, and so on.  this is useful for iterating entire tree 
hierarchies, basically treating a tree, like a list of items, flattening the 
hierarchy

your code will execute once for every single node you have in your return 
expression.  use the [.] expression to de-reference the currently iterated 
node

iterate executes immutable, meaning it will not modify its child 
nodes after it is done executing, and every iteration of the loop 
will execute on a 'virgin' version of its code.  this means that 
the code it executes will be reset back to what it originally was 
for every single iteration of the loop

thread safe"

magix.execute.iterate-sample
  _data
    items
      message1=>howdy world 1.0
      sub-1
        message2=>howdy world 2.0
        message3=>howdy world 3.0
      sub-2
        message4=>howdy world 4.0
        sub-3
          message5=>howdy world 5.0
      sub-3
        message6=>howdy world 6.0
      message7=>howdy world 7.0
  iterate=>[_data][items]
    if=>exist
      lhs=>[.].value
      code
        set=>[@][magix.viewport.show-message][message].value
          value=>[.].value


magix.execute.lambda-dox=>@"executes a piece of code

executes the expression in the [lambda] node as hyperlisp, creating 
a deep copy of the expression's nodes before execution

[lambda] can be given parameters, which will be accessible in the 
lambda code through the [$] collection.  anything you return as [$] 
from inside the code being executed, will become directly accessible 
as children nodes, from outside of the lambda execution, after the 
execution is finished

thread safe"

magix.execute.lambda-sample
  _data
    set=>[$][output].value
      value=>{0} {1}
        v0=>[$][input].value
        v1=>hansen
  lambda=>[_data]
    input=>thomas


magix.execute.override-dox=>@"overrides an active event with another

overrides the given active event from the [name] node's value with 
the active event from the [with] node's value.  if no [with] is given, 
existing override is removed

if you supply a [persist] parameter, and sets its value to false, then 
the override will not be persisted, and will only last until the 
application pool is restarted

thread safe"

magix.execute.override-sample
  override
    name=>namespace.foo
    with=>namespace.bar


magix.execute.app-startup-dox=>@"initialization of tunneled events

called during startup of application to make sure our active events, 
which are remotely overridden are being correctly re-mapped"


magix.execute.tunnel-dox=>@"overrides an active event to be invoked on another server

creates an external override towards the given [url] for the event found in [name].  
if you pass in a null value as a [url], or no [url] node, any existing tunnel for 
the named active event will be removed

make sure the other side has marked the active event as remotable.  once a method is 
'tunneled', it will no longer be raised locally, but every time the active event is 
raised internally within your server, it will be polymorphistically raised, on your 
[url] end-point server instead

if a [persist] parameter exists, and it has a value of false, then the tunnel will not 
be serialized into the data layer

both [name] and [url] can be either expressions or constants

thread safe"

magix.execute.tunnel-sample
  tunnel
    name=>magix.namespace.foo
    url=>http://127.0.0.1:8080


magix.execute.open-dox=>@"opens up an active event for remote invocation

allows the given [name] active event to be remotely invoked.  this means 
that other servers, can call your active event, on your server

you can create a server-api for web-services, by opening active events for 
being remotely invoked, and such connect servers together, either internally 
as a part of your server park, or by exposing functionality to other networks

if you set [persist] to false, then the opening of the active event will not 
be serialized into the data storage, meaning it will only last as long as the 
application is not restarted

[name] can be either an expression or a constant

thread safe"

magix.execute.open-sample
  open
    name=>magix.namespace.foo


magix.execute.close-dox=>@"closes an existing open active event

closes the active event found in [name], such that it no longer 
can be remotely invoked from other servers

if you set [persist] to false, then the closing of the active event 
will not be serialized into the data storage, meaning the closing 
will only last as long as the application is not restarted

[name] can be either an expression or a constant

thread safe"

magix.execute.close-sample
  close
    name=>magix.namespace.foo


magix.execute.remote-dox=>@"remotely invokes an active event

remotely invokes the active event from value on [remote] on the 
given [url], passing in all nodes in [pars] as parameters to your 
active event, returning any return values from event beneath [params]

this effectively raises an active event, except the event will be 
serialized over http, and invoked on another server, returning 
transparently back to the caller, as if it was invoked locally

both [url] and [name] can be either expressions or constants

thread safe"

magix.execute.remote-sample
  remote
    name=>magix.namespace.foo
    url=>http://127.0.0.1:8080
    params
      your-parameters-goes-here=>value of parameter


magix.execute.replace-dox=>@"replaces a string with another string

replaces the [what] value/expression with the [with] value/expression 
in the value of the [replace] node's expression

both [what] and [with] can be either constants or expressions.  [with] 
is optional, and if not given, the [what] parts of the value of 
[replace] will simply be removed.  the value of [replace] can be either 
a constant, or an expression.  both [what] and [with] can contain children 
nodes, which will serve as formatting expressions, possible to de-reference 
as {0}, {1} and so on

thread safe"

magix.execute.replace-sample
  _expression=>some value to be replaced
  replace=>[_expression].value
    what=>some
    with=>some other


magix.execute.execute-script-dox=>@"executes a piece of hyper lisp script

runs the hyperlisp script given in value of [script], putting all child 
nodes from underneath the [params] node into the [$] collection, accessible 
from inside the script, which again is able to return nodes through the [$] 
node, which will become children of the [params] node after execution

you can optionally supply a [file] parameter, which will be loaded through 
[magix.file.load], and executed.  if you supply a [file] parameter, you 
cannot supply a [script] parameter

both [file] and [script], can either be expressions, or constants

thread safe"

magix.execute.execute-script-sample
  execute-script
    params
      input=>hello world
    script=>@"
_data=>thomas
if=>equals
  lhs=>[_data].value
  rhs=>thomas
  code
    set=>[@][magix.viewport.show-message][message].value
      value=>[$][input].value
    magix.viewport.show-message
    set=>[$][output].value
      value=>dude's still thomas"


magix.execute.set-dox=>@"sets some node value, name or content

sets the given expression in the value of [set] to the value of 
expression, or constant, in [value] node

if you pass in no [value], the expression in value will be 
nullified.  meaning, if it's a node-list it will be emptied 
and the node removed.  if it's a value, the value will become 
null.  if it's a name, the name will be set to the empty string

the [value]'s value can be either a constant or an expression.  
the value of [set] must be an expression

you can set a value of a node to either a name, value of 
another node or a node-list.  you can set a node-list to 
another node-list, at which case the entire node will be 
exchanged with a deep copy of the node list return from 
[value].  you can set the name of a node to a string, 
either through a constant or an expression

you can also add up child nodes of the [value] node, 
which can be de-referenced as a string.format statement, 
such that {0} will be replaced with the value of the 
first child node from beneath [value], and {2} will be 
replaced with the value of the third child node from 
beneath the [value], and so on

if you try to set a node that does not exist, the node 
will be created, and added to the execution tree

thread safe"

magix.execute.set-sample
  _data
    children=>old value
  set=>[_data][children].value
    value=>new value


magix.execute.split-dox=>@"splits a string

splits the given expression or constant in the value of [split] according to the [what] 
content or [where] child nodes, and puts the result into the [result] return node as 
children nodes.  if you add a [trim] parameter, and set its value to true, then the 
string will be trimmed before it is split.  if you add no [where] or [what] node, but 
add a [trim] node being true, the string will be trimmed for all spacing characters, and 
returned unchanged besides from being trimmed

if you supply a [trim] node, and its value is anything but 'true', the characters in 
your trim node will be removed from the beginning and the end of your string

if [what] is given, but has null or empty value, then string will be split for every single 
character in it.  if [where] is used, then either value of [where] is expected to be one 
integer telling at which index the string should be split, or a list of children nodes 
underneath the [where] containing indexes for where to split the string is expected

both [what] and [where] value or nodes can be either a constant, or expression(s)

if you use [what] to split your string, then the parts which matches the [what] expression 
in your string, will be removed from the result set

thread safe"

magix.execute.split-sample
  _data=>some text which will be split for every space
  split=>[_data].value
    what=>@" "


magix.execute.stop-dox=>@"stops the execution of the current scope

stops the execution of the current scope in the tree

affects [while], [for-each] and other code scopes, such as events and event handlers

thread safe"

magix.execute.stop-sample
  _data=(int)>5
  while=>more-than-equals
    lhs=>[_data].value
    rhs=>1
    code
      using=>magix.math
        add
          =>[_data].value
          =>-1
      set=>[_data].value
        value=>[@][using][add].value
      stop


magix.execute.switch-dox=>@"executes logic according to value of string

[switch] creates a comparison between all the children [case] nodes, and executes the code 
within the [case] node who's value equals the content of the [switch] node

the [switch] node's value can be either a constant or an expression.  if no match is found, 
then [default] will be executed, if a [default] exist.  notice how both the [switch] node 
itself, and [case] nodes can be both expressions or constants

thread safe"

magix.execute.switch-sample
  _data=>3
  _success=>3
  switch=>[_data].value
    case=>1
      magix.viewport.show-message
        message=>ERROR!!
    case=>2
      magix.viewport.show-message
        message=>ERROR!!
    case=>[_success].value
      magix.viewport.show-message
        message=>success!
    default
      magix.viewport.show-message
        message=>ERROR!!


magix.execute.fork-dox=>@"spawns a new execution thread

spawns a new thread, which the given code block will be executed within

[fork] is useful for long operations, where you'd like to return to caller, before the operation is 
finished.  the entire node-list underneath the [fork] keyword, will be cloned, and passed into the 
magix.execute active event, for execution on a different thread

the forked thread will not be able to change any data on the original node set.  if the value of 
[fork] is true, the new thread will be executed as a fire-and-forget thread, bypassing any [wait] 
statements you might have

thread safe"

magix.execute.fork-sample
  fork
    _data
      value=>thomas
    if=>equals
      lhs=>[_data][value].value
      rhs=>thomas
      code
        _do-some-legthy
          _operation


magix.execute.wait-dox=>@"waits for multiple threads to finish

will wait for multiple treads to finish

all [fork] blocks created underneath [wait], will have to be finished, before the execution will 
leave the [wait] block.  you can optionally set a maximum number of milliseconds, before the wait 
is dismissed as an integer value of [wait]

when you create your threads with the [fork] statement inside a [wait], then when the wait is 
finished executing, the resulting code tree from all your [fork] statements will be copied 
into the original code tree.  this means that you can have fork statements modify the original 
code tree, returning their result back to the original code tree's main thread

you can only add [fork] statements beneath a [wait] statement

thread safe"

magix.execute.wait-sample
  wait=>10000
    fork
      _do-lenghty-job-1
    fork
      _do-lenghty-job-2


magix.execute.while-dox=>@"loops as long as condition is true

creates a loop that executes the underlaying code block repeatedly, as long as the 
comparison statement(s) in the value of [while] is true

the [while] is taking arguments similarly as both the [if] and [else-if].  see any of 
these active events to understand how to create a comparison statement(s) to check for 
in the while loop

while executes immutable, meaning it will not modify its children 
nodes after it is done executing, and every iteration of the loop 
will execute on a 'virgin' version of its code.  this means that 
the code it executes will be reset back to what it originally was 
for every single iteration of the loop

thread safe"

magix.execute.while-sample
  _data
    txt1=>hello world 1.0
    txt2=>hello world 2.0
    txt3=>hello world 3.0
  while=>not-equals
    lhs=>[_data].count
    rhs=>0
    code
      set=>[@][magix.viewport.show-message][message].value
        value=>[_data][0].value
      set=>[_data][0]
      magix.viewport.show-message
        message=>to be changed


magix.execute.with-dox=>@"temporary changes the data pointer

temporary changes the data pointer to the expression in its value.  
[with] must have an expression returning a node list

this is useful if you're handling several keywords in a row, where 
the expressions within them are all pointing deep into the execution 
tree somewhere

thread safe"

magix.execute.with-sample
  _data
    _somewhere
      _over
        items
          message1=>howdy world 1.0
          message2=>howdy world 2.0
          message3=>howdy world 3.0
          message4=>howdy world 4.0
          message5=>howdy world 5.0
          message6=>howdy world 6.0
          message7=>howdy world 7.0
  with=>[_data][_somewhere][_over]
    for-each=>[items]
      set=>[@][magix.viewport.show-message][message].value
        value=>[.].value


magix.execute.sort-dox=>@"sorts a node list

executes the underlaying code block appending [_first] and [_second] being 
two nodes from the list of nodes pointed to by the value of [sort] itself

expects to have [_result] being set underneath the instruction pointer to 
inform engine of which node is the node that comes before the other.  if no 
[_result] is set during execution of the code inside of [sort], then the nodes 
are assumed to be equal in regards to sorting

if [_result] is set to [_first], then [_first] is said to come before [_second].  
if [_result] is set to [_second], then [_second] is said to come before [_first]"

magix.execute.sort-sample
  _data
    item1
      dec=(dec)>110000
    item2
      dec=(dec)>10000
    item3
      dec=(dec)>1006
    item4
      dec=(dec)>1000
    item5
      dec=(dec)>12000
  sort=>[_data]
    if=>less-than
      lhs=>[@][_first][0][dec].value
      rhs=>[@][_second][0][dec].value
      code
        add=>[@][..][..][_result]
          value=>[@][..][..][_first]
    else-if=>more-than
      lhs=>[@][_first][0][dec].value
      rhs=>[@][_second][0][dec].value
      code
        add=>[@][..][..][_result]
          value=>[@][..][..][_second]














