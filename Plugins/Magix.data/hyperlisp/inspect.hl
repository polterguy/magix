

inspect=>@"contains the documentation for magix.data"


magix.data.application-startup-dox=>@"loads database from disc into memory

reloads serialized ram-based database into memory"


magix.data.transaction-dox=>@"initiates a database transaction

creates a database transaction.  unless [magix.data.commit] is raised before the scope of the 
transaction ends somehow, all changes done to the database inside of the transaction will be 
rolled back, and discarded.  this is useful to make sure a long operation is successful as a 
whole to allow changes to the database

if a transaction is active, no other threads will be able to access the database, and will 
have to wait for the transaction to finish, before they're allowed to read and write to and 
from the database

thread safe"

magix.data.transaction-sample
  magix.data.transaction
    magix.data.save
      value
        type=>magix.test.some-object
        name=>thomas
    throw=>we throw here

    // since this line is never executed, the changes to the database 
    // above will never be serialized, and discarded
    magix.data.commit


magix.data.commit-dox=>@"commits a database transaction

commits a database transaction.  if you have started a database transaction through for instance 
the [magix.data.transaction], then unless commit is explicitly raised before the scope of the 
transaction ends, the changes to the database inside of the transaction will be discarded

thread safe"

magix.data.commit-sample
  magix.data.transaction
    magix.data.save
      value
        type=>magix.test.some-object
        name=>thomas
    magix.data.commit


magix.data.load-dox=>@"loads a node from database

loads the first object matching the given [id] or the given [prototype].  it will return all 
objects matching your prototype if you supply a prototype node.  or the object matching your 
id if you supply an id.  if neither prototype nor id is given, it will load all objects from 
database

if you supply a prototype, it will return objects found as [objects], with child nodes of 
[objects] being the matching objects.  if you supply an [id] node, it will return the matched 
object as [value]

if you supply a [prototype], you can or together the results of multiple prototypes, by adding 
multiple prototypes by appending new prototypes as [or] nodes directly underneath the keyword 
itself

if you supply a prototype, you can make the engine perform a case-insensitive search by adding 
[case] and setting its value to false

if you supply a prototype, you can also sort by any of the top level nodes in your result by 
adding a [sort] parameter, and setting its name to be the name of the node you wish to sort 
by.  you can sort descending by that node by adding [descending] beneath [sort].  ascending 
is default

in addition to loading the actual object and its id(s), [revision-count] and [created] will 
also be returned for all objects matching your criteria.  [revision-count] is the number of 
times the object has been saved, and [created] is the date and time of creation of your object

if you supply a [prototype] and an [only-id], then only the ids, [revision-count] and [created] 
values of the objects that matches your prototype will be loaded, and not the actual content of 
your object

use [start] and [end] to fetch a specific slice of objects, [start] defaults to 0 and [end] defaults 
to -1, which means all objects matching criteria.  [start], [end] and [prototype] cannot be defined 
if [id] is given, since [id] is unique, and will make sure only one object is loaded

if a [prototype] node is given, it can contain node values with % to signify wildcards for a match 
operation.  to search for something actually containing a percentage sign '%', use two percentage 
signs to signify you're looking for one percentage sign like this '%%'

both [id], [prototype], [start] and [end] can be either constant values, nodes or expressions 
pointing to an id or a prototype object, which will be used as the criteria to load objects.  
no nodes in prototype can contain neither formatting values, nor expressions, since the [prototype] 
node is not evaluated in any form before being passed into the match algorithm

[id], if given,  can contains formatting expressions, such as {0}, {1} and so on, de-referencing 
children nodes of [id]

thread safe"

magix.data.load-sample
  magix.data.load
    prototype
      type=>magix.execute.event


magix.data.save-dox=>@"saves a node to the database

will serialize the given [value] node with the given [id] into the database

if no [id] is given, a unique identifier will be automatically assigned to the object, 
and returned as [id].  if an [id] is given, and an object with that same id exists, the 
existing object will be overwritten and updated.  both [value] and [id] can be either 
expressions or constant strings or nodes.  if [value] is an expression, it will be used as 
an expression pointing to a node that is to be saved, and the children node of the node 
pointed to in the expression of [value] are saved as the value of the object.  if [value] 
is an expression, it must be an expression returning a node list

[id] can contains formatting expressions, such as {0}, {1} and so on, de-referencing children 
nodes of [id]

thread safe"

magix.data.save-sample
  magix.data.save
    id=>object-id
    value
      some-value=>value of object
        some-inner-value=>howdy
      name=>john doe


magix.data.remove-dox=>@"removes a node from the database

removes the given [id] or [prototype] object(s) from your database

both [id] and [prototype] can be either expressions or constant values.  if an id is 
given, you cannot supply a prototype.  if you supply a prototype, then no id can be 
supplied.  if you supply a prototype, you can use wildcard comparisons by using '%' 
as a wildcard equality comparison.  to search for a percentage sign, use two percentage 
signs to signify you're looking for one, like this '%%'

if you supply a [prototype], you can or together the results of multiple prototypes, by adding 
multiple prototypes by appending new prototypes as [or] nodes directly underneath the keyword 
itself

if you supply a prototype, you can make the engine perform a case-insensitive search by adding 
[case] and setting its value to false

the active event will return the number of records actually deleted as [affected-records]

[id] can contains formatting expressions, such as {0}, {1} and so on, de-referencing children 
nodes of [id]

thread safe"

magix.data.remove-sample
  magix.data.remove
    id=>some-id-to-some-object


magix.data.count-dox=>@"counts objects in database

returns the number of objects in database matching [prototype] as [count].  if no [prototype] 
is given, all objects in database will be counted.  [prototype], if given, can be either an 
expression or a constant.  number of objects matching criteria is returned as [count]

if you supply a [prototype], you can or together the results of multiple prototypes, by adding 
multiple prototypes by appending new prototypes as [or] nodes directly underneath the keyword 
itself

if you supply a prototype, you can make the engine perform a case-insensitive search by adding 
[case] and setting its value to false

thread safe"

magix.data.count-sample
  magix.data.count
    prototype
      type=>magix.execute.event





































































