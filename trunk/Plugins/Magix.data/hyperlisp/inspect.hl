

inspect=>@"contains the documentation for magix.data"


magix.data.application-startup-dox=>@"loads database from disc into memory

reloads serialized ram-based database into memory"


magix.data.transaction-dox=>@"initiates a database transaction

creates a database transaction.  unless [magix.data.commit] is raised before the scope of the 
transaction ends somehow, all changes done to the database inside of the transaction will be 
rolled back, and discarded.  this is useful to make sure a long operation is successful as a 
whole to allow changes to the database

if a transaction is active, no other threads will be able to access the database, and will 
have to wait for the transaction to finish, before they're allowed to read and write to and 
from the database

thread safe"

magix.data.transaction-sample
  magix.data.transaction
    magix.data.save
      value
        type=>magix.test.some-object
        name=>thomas
    throw=>we throw here

    // since this line is never executed, the changes to the database 
    // above will never be serialized, and discarded
    magix.data.commit


magix.data.commit-dox=>@"commits a database transaction

commits a database transaction.  if you have started a database transaction through for instance 
the [magix.data.transaction], then unless commit is explicitly raised before the scope of the 
transaction ends, the changes to the database inside of the transaction will be discarded

thread safe"

magix.data.commit-sample
  magix.data.transaction
    magix.data.save
      value
        type=>magix.test.some-object
        name=>thomas
    magix.data.commit


magix.data.load-dox=>@"loads a node from database

loads the first object matching the given [id] or the given [prototype].  it will return all 
objects matching your prototype if you supply a prototype node.  or the object matching your 
id if you supply an id.  if neither prototype nor id is given, it will load all objects from 
database

if you supply a prototype, it will return objects found as [objects], with child nodes of 
[objects] being the matching objects.  if you supply an [id] node, it will return the matched 
object as [value]

in addition to loading the actual object and its id(s), [revision-count] and [created] will 
also be returned for all objects matching your criteria.  [revision-count] is the number of 
times the object has been saved, and [created] is the date and time of creation of your object

if you supply a [prototype] and an [only-id], then only the ids, [revision-count] and [created] 
values of the objects that matches your prototype will be loaded, and not the actual content of 
your object

use [start] and [end] to fetch a specific slice of objects, [start] defaults to 0 and [end] defaults 
to -1, which means all objects matching criteria.  [start], [end] and [prototype] cannot be defined 
if [id] is given, since [id] is unique, and will make sure only one object is loaded

if a [prototype] node is given, it can contain node values with % to signify wildcards for a match 
operation.  both [id], [prototype], [start] and [end] can be either constant values, nodes or 
expressions pointing to an id or a prototype object, which will be used 
as the criteria to load objects.  no nodes in prototype can contain neither formatting values, 
nor expressions, since the [prototype] node is not evaluated in any form before being passed into 
the match algorithm

[id], if given,  can contains formatting expressions, such as {0}, {1} and so on, de-referencing 
children nodes of [id]

thread safe"

magix.data.load-sample
  magix.data.load
    prototype
      type=>magix.execute.event


magix.data.save-dox=>@"saves a node to the database

will serialize the given [value] node with the given [id] in the persistent data storage

if no [id] is given, a unique identifier will be automatically assigned to the object, 
and returned as [id].  if an [id] is given, and an object with that same id exists, the 
existing object will be overwritten and updated.  both the [value] and [id] can either be 
expressions or constant strings or nodes.  if [value] is an expression, it will be used as 
an expression pointing to a node that is to be saved, and the children node of the node 
pointed to in the expression of [value] are saved as the value of the object

[id] can contains formatting expressions, such as {0}, {1} and so on, de-referencing children 
nodes of [id]

thread safe"

magix.data.save-sample
  magix.data.save
    id=>object-id
    value
      some-value=>value of object
        some-inner-value=>howdy
      name=>john doe


magix.data.remove-dox=>@"removes a node from the database

removes the given [id] or [prototype] object(s) from your persistent data storage

both [id] and [prototype] can be either expressions or constant values.  if an id is 
given, you cannot supply a prototype.  if you supply a prototype, then no id can be 
supplied.  if you supply a prototype, you can use wildcard comparisons by using the 
% sign as a wildcard equality comparison

[id] can contains formatting expressions, such as {0}, {1} and so on, de-referencing children 
nodes of [id]

thread safe"

magix.data.remove-sample
  magix.data.remove
    id=>some-id-to-some-object


magix.data.count-dox=>@"counts objects in database

returns the total number of objects in data storage as [count].  add [prototype] 
to filter results.  [prototype], if given, can be either an expression or a constant.  
if no prototype is given, the active event will return al objects in database.  objects 
are returned as [count]

thread safe"

magix.data.count-sample
  magix.data.count
    prototype
      type=>magix.execute.event





































































