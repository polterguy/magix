
inspect=>@"documentation for Magix.execute

contains the documentation for all active events in the 
Magix.execute assembly"


magix.execute.add-dox=>@"adds nodes to a node

creates a deep copy of the node returned by the expression in the [value] node, and appends 
it into the expression found in [add].  if no [value] node is given, and no [values] node is 
given, then all children of [add] will be added.  the [add] node must have en expression 
returning a node list

if a [value] node exists, with an expression returning a node list, then the entire node tree 
will be copied, with its children, including the node returned from [value] itself

if the destination node does not exist, then it will be created

a [values] node can optionally be given instead of [value].  if a [values] node is given, then 
only the children of the node returned by the expression in [values] will be added to the nodes 
found in the expression of [add]

if a [value] node exists, and it is a constant, or an expression returning anything but a node list, 
then a node with the name returned from the constant or expression of the [value] node will be 
added to the node list of the expression returned by [add].  in this case, one node will be added 
to the node list in the [add] expression, with the name of the [value] node's value.   if you supply 
a [value] node, who's value is not a node list, you can optionally also supply an additional [value] 
node as a child of the first [value] node, who's expression or constant value will become the value 
of the node added to the [add] node's collection.  if you supply the second [value] node, and its 
return value is of type string, you can optionally supply this node's value as a formatting expression, 
using {0} and {1} to de-reference items being children of the second [value] node, to format strings

thread safe"

magix.execute.add-sample
  _copy0
  _copy1
  _copy2
  _copy3
  _data
    children=>original
    children1=>will be copied
      item1=>will be copied too
      item2=>will also be copied
  add=>[_copy0]
    value=>[_data]
  add=>[_copy1]
    values=>[_data]
  add=>[_copy2]
    some-node=>some node value
      another-node
        with-a-child=>@"this is a multiline 
value to demonstrate you can 
add nodes which have text 
spanning multiple lines"
  add=>[_copy3]
    value=>new-node-name
      value=>new node value {0}
        =>with formatting expressions
  add=>[_does-not-exist]
    value=>_dynamically-created-with-no-value


magix.execute.node-2-code-dox=>@"transforms a node to text

will transform the [node] node to code syntax, and return it in [code].  [node] can either have 
its nodes as the value of the [node], as children nodes directly underneath the [node] node, or 
as an expression returned from the node node's value.  the code returned will be the textual 
representation of the original tree hierarchy with hyperlisp syntax.  two spaces opens up a child 
collection.  => separates name and value of node, etc

code returned might also contain type information for types of int, decimal, datetime and bool.  
if [remove-root] is true, then the root node will be removed, and not be a part of the code 
returned

thread safe"

magix.execute.node-2-code-sample
  node-2-code
    node
      some-node
        a-child=>howdy
        another-child=>hello
      another-node=>yo!


magix.execute.code-2-node-dox=>@"transforms hyperlisp text code to nodes

will transform the [code] node to a node tree

the code will be returned in [node] as a node structure.  the code will 
be parsed as hyperlisp code, meaning two indentations opens up a new 
children collection, =>assigns a value to the node with the name to the 
left of the => operator, etc

thread safe"

magix.execute.code-2-node-sample
  code-2-node
    code=>@"
code
  goes
    here"


magix.execute.debug-dox=>@"shows a debug dialog of the node stack

shows the entire stack of hyperlisp code in a modal message box.  
alternatively, you can submit an expression, pointing to a node list, 
to show only a subsection of the tree

not thread safe"

magix.execute.debug-sample
  magix.execute
    set=>[@][foo.bar].value
      value=>true
  debug=>[magix.execute]


magix.execute.application-startup-dox=>@"maps serialized active events

called during startup of application 
to make sure our active events, which are dynamically tied towards serialized hyper 
lisp blocks of code, are being correctly re-mapped"


magix.execute.event-dox=>@"creates a new active event

overrides the active event in [name] with the hyperlisp code in the [code] expression.  
these types of active events can take and return parameters.  if you wish to pass in or 
retrieve parameters, then as you invoke the function, just append your parameters 
underneath the function invocation, and they will be passed into the function, where 
they will be accessible underneath the [$] node, appended as the last parts of your code 
block, into your function invocation.  from outside of the active event itself, you can 
access these parameters directly underneath the active event itself

any existing event with the name from the [event] node's value will be deleted, if you 
pass in no [code] block.  if you set the [remotable] node to true, then the active event 
will be possible to invoke by remote servers, and marked as open.  if you set [persist] 
to false, then the active event will not be serialized into the data storage, meaning it 
will only last as long as the application is not restarted.  this is useful for active 
events whom are created for instance during the startup of your application, since it 
will save time, since they will anyway be overwritten the next time your application 
restarts

if you add an [inspect] node, then this will become the inspect value of the active event.  
[inspect] can be either an expression or a constant, and can also contain formatting 
expressions, such as {0} and {1}, referencing values beneath the inspect node

[name] can be either an expression, or a constant

thread safe"

magix.execute.event-sample
  event
    name=>foo.bar
    remotable=(bool)>False
    persist=(bool)>False
    code
      _data=>thomas
      _backup=>thomas
      if=>equals
        lhs=>[_data].value
        rhs=>[_backup].value
        code
          set=>[$][output].value
            value=>return-value
          set=>[/][magix.viewport.show-message][message].value
            value=>[$][input].value
      magix.viewport.show-message
  foo.bar
    input=>hello world 2.0
  event
    name=>foo.bar


magix.execute._active-event-2-code-callback-dox=>@"maps dynamic active events

maps dynamic active events towards their stored code.  is the main entry point for 
dynamically created active events, and will map the active event towards the actual 
code intended to be executed"


magix.execute._active-event-2-code-callback-dynamic-dox=>@"dynamically created active event

dynamically created active event, created with the [event] keyword.  
thread safety is dependent upon the active events raised internally 
within the active event"


magix.execute.list-events-dox=>@"lists all active events in the system

returns all active events within the system.  add [all], [open], [remoted], 
[overridden] or [begins-with] to filter the events returned

active events are returned in [events].  list-events will not return unit 
tests and active events starting with '_' if [all] is false.  if [all], 
[open], [remoted] or [overridden] is defined, it will return all events 
fullfilling criteria, regardless of whether or not they are private events, 
tests or don't match the [begins-with] parameter

thread safe"

magix.execute.list-events-sample
  list-events
    begins-with=>magix.execute


magix.execute.try-dox=>@"creates a try block to handle exceptions

use the [try] keyword to create a block of unsafe [code] to execute, where 
the code within the [code] block might throw an exception, and you wish to 
be notified if it does, and handle it, either in a [catch] block of code, or 
a [finally] block of code, or both

when you create a [try] block, you must have a [code] block beneath it, in 
addition to either a [catch] block, a [finally] block, or both.  your [catch] node 
might also optionally contain a value, which will be used as an 'exception filter'

if your [catch] node has a value, only exceptions thrown with [type] matching 
the value of your [catch] block will be handled by your [catch] block, if your 
exception is a hyperlisp exception.  if your exception is a clr exception, and 
your [catch] node has a value, then the value of your [catch] node is supposed to 
match the type name of the clr exception you wish to catch

if your [catch] node does not have a value, it will handle all exceptions, both 
hyperlisp exceptions, in addition to all types of managed clr exceptions

thread safe"

magix.execute.try-sample
  magix.viewport.show-message
    message=>@"as you can see, there are 5 messages shown here, 
including this.&nbsp;&nbsp;but two catch blocks are never executed, since 
they are catching the wrong type of exception"
    time=>30000
  try
    code
      throw=>to try or not to try
    catch
      set=>[@][magix.viewport.show-message][message].value
        value=>[@][exception].value
      magix.viewport.show-message
  try
    code
      try
        code
          throw=>this is the exception message
            type=>correct-type
        catch=>wrong-type
          magix.viewport.show-message
            message=>this message box will never show
        finally
          magix.viewport.show-message
            message=>@"this message box will show up though, 
since a finally statement is guaranteed to be executed, 
regardless of whether or not an exception is thrown"
    catch=>correct-type
      set=>[@][magix.viewport.show-message][message].value
        value=>[@][exception].value
      magix.viewport.show-message
  try
    code
      try
        code
          magix.file.load
            file=>i-hope-this-file-does-not-exist.hl
        catch=>wrong-type
          magix.viewport.show-message
            message=>this message box will never show neither
    catch=>System.IO.FileNotFoundException
      set=>[@][magix.viewport.show-message][message].value
        value=>[@][exception].value
      magix.viewport.show-message


magix.execute.throw-dox=>@"throws an exception

throws an exception, which will stop the current execution stack, and halt 
back to the previous matched catch, in the stack of active events.  [exception] 
in [catch] becomes the value of the [throw] node, or the exception message.  
use throw together with [try] to handle errors

add up an additional [type] when you throw your exceptions, to create a specific 
type of exception, which must match the value of your [catch] node to have your 
catch actually handle your exception

you can create as many [catch] blocks as you wish, with different types, such 
that you have different [catch] blocks for each type of exception that might occur

from within a [catch] block, you can rethrow the exception you handled, by using 
the [throw] keyword, with no value.  this allows you to handle an exception, 
while still rethrowing it to further unroll the stack upwards

to create active event handlers that handles all exceptions, you can create an 
active event who's name is 'magix.execute.exception', which might be useful for 
logging purposes and such

thread safe"

magix.execute.throw-sample
  try
    code
      try
        code
          throw=>this is the exception message
            type=>correct-type
        catch=>wrong-type
          magix.viewport.show-message
            message=>@"this message box will never show, since the 
exception type it handles is not the correct type"
    catch=>correct-type
      set=>[@][magix.viewport.show-message][message].value
        value=>[@][exception].value
      magix.viewport.show-message
  try
    code
      try
        code
          throw=>this is the second exception message
        catch
          magix.viewport.show-message
            message=>caught exception
          throw
    catch
      set=>[@][magix.viewport.show-message][message].value
        value=>[@][exception].value
      magix.viewport.show-message
  try
    code
      throw=>this is the second exception message
        type=>correct-type
    catch=>wrong-type
      magix.viewport.show-message
        message=>this message box never shows
    catch=>correct-type
      magix.viewport.show-message
        message=>the correct [catch] block was executed


magix.execute.using-dox=>@"changes the default namespace

changes the default namespace for the current scope.  this allows you to raise 
active events which you normally would have to raise with a period in their 
name, without the period, which allows active events which normally cannot 
access the entire execution tree, to access the entire code tree

thread safe"

magix.execute.using-sample
  _result
  using=>magix.math
    add=>[_result]
      =(int)>4
      =(int)>1
  using=>magix.viewport
    show-message
      message=>the result of our add operation is; {0}
        =>[_result].value


magix.execute.sandbox-dox=>@"restricts the active events possible to raise

changes the execution engine, making sure only keywords and active events in 
our [whitelist] are legal keywords

this is a useful feature to prevent external sources, or untrusted scripts, to 
execute malicious code.  all keywords and active events which are not declared in 
the [whitelist] parameter, are illegal to executed as long as the instruction 
pointer is within the scope of the [code] block, which declares the block of code 
that is to be sandboxed

thread safe"

magix.execute.sandbox-sample
  sandbox
    whitelist
      foo
    code
      bar=>throws exception, since [bar] is not in [whitelist]


magix.execute.execute-dox=>@"main hyperlisp execution entry point

executes the incoming parameters as hyperlisp, meaning it will raise everything 
containing a period ('.') as an active event, while everything not starting with 
an underscore ('_'), and not containing a period (.), will be assumed to be a 
hyperlisp keyword, and have the current namespace prepended in front of it, before 
it is raised as an active event.  the default namespace is 'magix.execute', but this 
can be overridden with the [using] keyword

a hyperlisp keyword will have access to the entire data tree, while a normal active 
event can only access the parts of the tree from underneath its own node

you can change the namespace prepended in front of all hyperlisp keywords with the 
keyword [using], and such modify the namespace prepended in front of every hyperlisp 
keyword to whatever you choose for yourself, and in such a way, create hyperlisp 
keywords of existing active events, from any namespace you choose

you can alternatively pass in an expression as the value of [execute] which will 
execute that expression as hyperlisp.  if you do, then your expression must return 
a node list, and you can not use the fully qualified version of magix.execute.execute, 
but must use only [execute] as your keyword

if you fully declare your execute keyword, by appending the magix. namespace in 
front of it, like [magix.execute], then the hyperlisp code beneath [magix.execute] 
will be executed such that it does not have acccess to the code outside of itself.  
this is useful to make sure code does not have side-effects on other parts of your 
code

thread safe"

magix.execute.execute-sample
  _data
    value=>thomas
  execute
    if=>equals
      lhs=>[_data][value].value
      rhs=>thomas
      code
        magix.execute
          _data=>hi thomas
          execute=>[_exe-node]
          _exe-node
            using=>magix.viewport
              show-message
                message=>[_data].value
    else
      magix.viewport.show-message
        message=>hi stranger


magix.execute.for-each-dox=>@"iterates through a node list

loops through all the nodes in the given node-list expression, 
setting the data-pointer to the currently iterated item

your code will execute once for every single node you have in 
your return expression.  use the [.] expression to de-reference 
the currently iterated node

for-each executes immutable, meaning every iteration will get a 
fresh copy of the code block inside of your [for-each], and every 
iteration of the loop will execute on a 'virgin' version of its 
code.  this means that the code it executes will be reset back 
to the state it originally was in for every single iteration 
of the loop

to stop a [for-each] loop, you can use the [stop] keyword

thread safe"

magix.execute.for-each-sample
  _data
    items
      message1=>howdy world 1.0
      message2=>howdy world 2.0
      message3=>howdy world 3.0
      message4=>howdy world 4.0
      message5=>howdy world 5.0
      message6=>howdy world 6.0
      message7=>howdy world 7.0
      stop-item=>stop here
      message8=>will not show
  for-each=>[_data][items]
    if=>equals
      lhs=>[.].value
      rhs=>stop here
      code
        stop
    set=>[@][magix.viewport.show-message][message].value
      value=>[.].value


magix.execute.if-dox=>@"checks statement and executes code if true

executes the [code] block of nodes as an execution block, but only if 
the [if] statement returns true

pair your [if] statements together with [else-if] and [else] to create 
branching logic and control of flow within your program.  if an [if]
statement returns true, then no paired [else-if] or [else] statements 
will be executed

the values compared must be given through [lhs] and [rhs], which means 
'left-hand-side' and 'right-hand-side', and the operator used to compare 
the [lhs] and the [rhs] nodes must be given using the value of the [if] 
node.  legal values for the operator is 'exist', 'not-exist', 'equals', 
'not-equals', 'less-than', 'more-than', 'less-than-equals', 
'more-than-equals', 'regex-match' and 'not-regex-match'

if you use 'regex-match' or 'not-regex-match' as your operator, then the 
regular expression you wish to use must be given in the [lhs] node, and 
the value or expression where you wish to find your match be given through 
the [rhs] node.  please notice that if you use regular expressions, then 
if your regular expression starts with a '[', it must be escaped by 
appending an '\' in front of it, otherwise the expression engine will 
think it is an expression leading to another node

[lhs] means 'left-hand-side'.  the lhs node is conceptually to the left 
of the operator.  [rhs] means 'right-hand-side', and is conceptually to 
the right of the operator.  this means that if you have an lhs value of 
'x' and an rhs value of 'y' and your operator is 'equals', then the 
full comparison statement becomes 'if x equals y'.  if you have an 
operator of 'more-than', and an [lhs] of 5 and an [rhs] of 4, then 
the full statement becomes 'if 5 is more-than 4', which of course 
will evaluate to true.  both [lhs], [rhs] and the operator value of your 
[if] can be either constants or expressions

[lhs] and [rhs] can contain formatting expressions, such as {0} and {1},
de-referencing children nodes of [lhs] and [rhs]

depending upon the comparison operator you use, the [rhs] node might 
not be necessary.  for instance, 'exist' does not need a right-hand-side, 
or an rhs node, since it only checks for the existence of one specific 
node, value or name

you can optionally also supply as many [or] and/or [and] nodes beneath 
your [if] node.  if you do, then these are additional statements that 
needs to return true to make the [if] statement become true as a whole.  
if you supply an [or] and/or an [and] statement beneath your [if] or 
[else-if], then you must add up a comparison operator as the value of 
your [and] and [or] statements, and another pair of [lhs] and [rhs] 
nodes beneath your [and] and [or] statements

the engine will convert automatically between int, decimal, date and 
bool, or resort to string if no conversion is possible.  you can compare 
two node trees in [lhs] and [rhs], which means that the node trees will 
be compared deeply, comparing their name, value and children for equality

thread safe"

magix.execute.if-sample
  _data
    item=>cache-object
    cache
  _comparison
    operator=>equals
  if=>not-equals
    lhs=>[_data][item].value
    rhs=>[_data][1].name
    and=>not-exist
      lhs=>[_data].value
    code
      magix.viewport.show-message
        message=>not equal, and no _data value
  if=>equals
    lhs=>[_data][item].value
    rhs=>cache-{0}
      =>object
    code
      magix.viewport.show-message
        message=>the value of item is 'cache-object'
  if=>[_comparison][operator].value
    lhs=>5
    rhs=>5
    code
      magix.viewport.show-message
        message=>the third [if] statement evaluated to true


magix.execute.else-if-dox=>@"checks statement and executes code if true

executes the [code] block of nodes as an execution block, but only if 
the [else-if] statement returns true, and no previous [if] or [else-if] 
have been executed

pair your [else-if] statements together with [if] and [else] to create 
branching logic and control of flow within your program.  if an [if]
statement returns true, then no paired [else-if] or [else] statements 
will be executed.  the else-if statement can only follow directly after 
an [if] statement, or another [else-if] statement

the values compared must be given through [lhs] and [rhs], which means 
'left-hand-side' and 'right-hand-side', and the operator used to compare 
the [lhs] and the [rhs] nodes must be given using the value of the [else-if] 
node.  legal values for the operator is 'exist', 'not-exist', 'equals', 
'not-equals', 'less-than', 'more-than', 'less-than-equals', 
'more-than-equals', 'regex-match' and 'not-regex-match'

if you use 'regex-match' or 'not-regex-match' as your operator, then the 
regular expression you wish to use must be given in the [lhs] node, and 
the value or expression where you wish to find your match be given through 
the [rhs] node.  please notice that if you use regular expressions, then 
if your regular expression starts with a '[', it must be escaped by 
appending an '\' in front of it, otherwise the expression engine will 
think it is an expression leading to another node


[lhs] means 'left-hand-side'.  the lhs node is to the left of the 
operator.  [rhs] means 'right-hand-side', and is conceptually to the 
right of the operator.  this means that if you have an lhs value of 
'x' and an rhs value of 'y' and your operator is 'equals', then the 
full comparison statement becomes 'if x equals y'.  if you have an 
operator of 'more-than', and an [lhs] of 5 and an [rhs] of 4, then 
the full statement becomes 'if 5 is more-than 4', which of course 
will evaluate to true.  both [lhs] and [rhs] can be either constants 
or expressions

depending upon the comparison operator you use, the rhs node might 
not be necessary.  for instance, 'exist' does not need a right-hand-side, 
or an rhs node, simply since it only checks for the existence of one 
specific node, value or name

you can optionally also supply as many [or] and/or [and] nodes beneath 
your [else-if] node.  if you do, then these are additional statements that 
needs to return true to make the if statement become true as a whole.  
if you supply an or and/or an and statement beneath your if or else-if, 
then you must add up a comparison operator as the value of your [and] 
and [or] statement, and another pair of [lhs] and [rhs] nodes beneath 
your and and or statements

the engine will convert automatically between int, decimal, date and 
bool, or resort to string if no conversion is possible.  you can compare 
two node trees in [lhs] and [rhs], which means that the node trees will 
be compared deeply, comparing their name, value and children for equality

thread safe"

magix.execute.else-if-sample
  _data
    node
  if=>exist
    lhs=>[_data][node].value
    code
      magix.viewport.show-message
        message=>darn it
  else-if=>exist
    lhs=>[_data][node]
    code
      magix.viewport.show-message
        message=>puuh


magix.execute.else-dox=>@"default execution of if and else-if

executes the underlaying code block, but only if no paired [if] 
or [else-if] statement has been executed.  pair up your [else] 
with [if] and [else-if] to create branching in your code

thread safe"

magix.execute.else-sample
  if=>exist
    lhs=>[_not-existing-node]
    code
      magix.viewport.show-message
        message=>ohh crap
  else
    magix.viewport.show-message
      message=>yup, still sane


magix.execute.index-of-dox=>@"returns index(es) of a string

returns the index of all occurences of the [what] constant 
or expression as nodes containing the integer value of where match 
was found underneath the [result] return node

if [case] equals false, the search will ignore casing of text when 
looking for a match.  by default, the engine will do a case sensitive 
search, unless [case] is false

[what] can containg formatting expressions such as {0} and {1}, 
de-referencing children nodes beneath the [what] node

thread safe"

magix.execute.index-of-sample
  _data=>this will return the position of all 'r' characters in string
  index-of=>[_data].value
    what=>r


magix.execute.iterate-dox=>@"iterates a node tree

loops through all the nodes in the given node-list expression, flattening 
the hierarchy, setting the data-pointer to the currently processed item

notice how this differs in regards to the [for-each] keyword.  the for-each 
only iterates over the children of the nodes in its expression.  while the 
[iterate] keyword will iterate the entire tree hierarchy, including all 
children of the nodes in the expression, their children, and their children's 
children, and so on.  this is useful for iterating entire tree hierarchies, 
basically treating a tree, like a list of items, flattening the hierarchy

your code will execute once for every single node you have in your return 
expression.  use the [.] expression to de-reference the currently iterated 
node

iterate executes immutable, meaning it will not modify its child 
nodes after it is done executing, and every iteration of the loop 
will execute on a 'virgin' version of its code.  this means that 
the code it executes will be reset back to what it originally was 
before execution for every single iteration of the loop

thread safe"

magix.execute.iterate-sample
  _data
    items
      message1=>howdy world 1.0
      sub-1
        message2=>howdy world 2.0
        message3=>howdy world 3.0
      sub-2
        message4=>howdy world 4.0
        sub-3
          message5=>howdy world 5.0
      sub-3
        message6=>howdy world 6.0
      message7=>howdy world 7.0
  iterate=>[_data][items]
    if=>exist
      lhs=>[.].value
      code
        set=>[@][magix.viewport.show-message][message].value
          value=>[.].value


magix.execute.lambda-dox=>@"executes a piece of code immutable

executes the expression in the [lambda] node as hyperlisp immutable, 
creating a deep copy of the expression's nodes before execution

[lambda] can be given parameters, which will be accessible in the 
lambda code executed through the [$] collection.  anything you 
return as [$] from inside the code being executed, will become 
directly accessible as children nodes of the [lambda], from outside 
of the lambda execution, after the execution is finished

thread safe"

magix.execute.lambda-sample
  _data
    set=>[$][output].value
      value=>{0} {1}
        v0=>[$][input].value
        v1=>hansen
  lambda=>[_data]
    input=>thomas


magix.execute.override-dox=>@"overrides an active event with another

overrides the given active event from the [name] node's value with 
the active event from the [with] node's value.  if no [with] is given, 
existing override is removed

if you supply a [persist] parameter, and sets its value to false, then 
the override will not be persisted, and will only last until the 
application pool is restarted

thread safe"

magix.execute.override-sample
  override
    name=>namespace.foo
    with=>namespace.bar


magix.execute.app-startup-dox=>@"initialization of tunneled events

called during startup of application to make sure our active events, 
which are remotely overridden are being correctly re-mapped"


magix.execute.tunnel-dox=>@"overrides an active event to be invoked on another server

creates an external override towards the given [url] for the event found in [name].  
if you pass in a null value as a [url], or no [url] node, any existing tunnel for 
the named active event will be removed

make sure the other side has marked the active event as remotable.  once a method is 
'tunneled', it will no longer be raised locally, but every time the active event is 
raised internally within your server, it will be polymorphistically raised, on your 
[url] end-point server instead

if a [persist] parameter exists, and it has a value of false, then the tunnel will not 
be serialized into the data layer

both [name] and [url] can be either expressions or constants

thread safe"

magix.execute.tunnel-sample
  tunnel
    name=>magix.namespace.foo
    url=>http://127.0.0.1:8080


magix.execute.open-dox=>@"opens up an active event for remote invocation

allows the given [name] active event to be remotely invoked.  this means 
that other servers, can call your active event, on your server

you can create a server-api for web-services, by opening active events for 
being remotely invoked, and such connect servers together, either internally 
as a part of your server park, or by exposing functionality to other networks

if you set [persist] to false, then the opening of the active event will not 
be serialized into the data storage, meaning it will only last as long as the 
application is not restarted

[name] can be either an expression or a constant

thread safe"

magix.execute.open-sample
  open
    name=>magix.namespace.foo


magix.execute.close-dox=>@"closes an existing open active event

closes the active event found in [name], such that it no longer 
can be remotely invoked from other servers

if you set [persist] to false, then the closing of the active event 
will not be serialized into the data storage, meaning the closing 
will only last as long as the application is not restarted

[name] can be either an expression or a constant

thread safe"

magix.execute.close-sample
  close
    name=>magix.namespace.foo


magix.execute.remote-dox=>@"remotely invokes an active event

remotely invokes the active event from value on [remote] on the 
given [url], passing in all nodes in [pars] as parameters to your 
active event, returning any return values from event beneath [params]

this effectively raises an active event, except the event will be 
serialized over http, and invoked on another server, returning 
transparently back to the caller, as if it was invoked locally

both [url] and [name] can be either expressions or constants

thread safe"

magix.execute.remote-sample
  remote
    name=>magix.namespace.foo
    url=>http://127.0.0.1:8080
    params
      your-parameters-goes-here=>value of parameter


magix.execute.replace-dox=>@"replaces a string with another string

replaces the [what] value/expression with the [with] value/expression 
in the value of the expression found in the [replace] node

both [what] and [with] can be either constants or expressions.  [with] 
is optional, and if not given, the [what] parts of the value of 
[replace] will simply be removed

both [what] and [with] can contain children nodes, which will serve as 
formatting expressions, possible to de-reference as {0}, {1} and so on

you can use \n, \r and \t in both your [what] and [with] values to 
signify you want to replace occurrencies of line-feed, carriage-return 
or tabs

alternatively you can supply a [regex] instead of a [what] parameter, 
which means that replace will be doing a regular expression replace 
instead of a traditional replacement

thread safe"

magix.execute.replace-sample
  _expression=>some value to be replaced
  replace=>[_expression].value
    what=>to be replaced
    with=>has now been updated
  _expression2=>@"some other value
to be replaced""
  replace=>[_expression2].value
    what=>\n
    with=>@" "
  replace=>[_expression2].value
    what=>\r


magix.execute.execute-script-dox=>@"executes a piece of hyper lisp script

runs the hyperlisp script given in value of [script], putting all child 
nodes from underneath the [params] node into the [$] collection, accessible 
from inside the script, which again is able to return nodes through the [$] 
node, which will become children of the [params] node after execution

you can optionally supply a [file] parameter, which will be loaded through 
[magix.file.load], and executed.  if you supply a [file] parameter, you 
cannot supply a [script] parameter

both [file] and [script], can either be expressions, or constants

thread safe"

magix.execute.execute-script-sample
  execute-script
    params
      input=>hello world
    script=>@"
_data=>thomas
if=>equals
  lhs=>[_data].value
  rhs=>thomas
  code
    set=>[@][magix.viewport.show-message][message].value
      value=>[$][input].value
    magix.viewport.show-message
    set=>[$][output].value
      value=>dude's still thomas"


magix.execute.set-dox=>@"sets some node value, name or content

sets the given expression in the value of [set] to the value of 
expression, or constant, in [value] node

if you pass in no [value], the expression in value will be 
nullified.  meaning, if it's a node-list it will be emptied 
and the node removed.  if it's a value, the value will become 
null.  if it's a name, the name will be set to the empty string

the [value]'s value can be either a constant or an expression.  
the value of [set] must be an expression

you can set a value of a node to either a name, value of 
another node or a node-list.  you can set a node-list to 
another node-list, at which case the entire node will be 
exchanged with a deep copy of the node list return from 
[value].  you can set the name of a node to a string, 
either through a constant or an expression

you can also add up child nodes of the [value] node, 
which can be de-referenced as a string.format statement, 
such that {0} will be replaced with the value of the 
first child node from beneath [value], and {2} will be 
replaced with the value of the third child node from 
beneath the [value], and so on

if you try to set a node that does not exist, the node 
will be created, and added to the execution tree

thread safe"

magix.execute.set-sample
  _data
    children=>old value
  set=>[_data][children].value
    value=>new value


magix.execute.split-dox=>@"splits a string

splits the given expression or constant in the value of [split] according to the [what] 
content, [where] child nodes or [regex], and puts the result into the [result] return node as 
children nodes.  if you add a [trim] parameter, and set its value to true, then the 
string will be trimmed for all white space characters before it is split.  if you add no 
[where] or [what] node, but add a [trim] node being true, the string will be trimmed for 
all spacing characters, and returned unchanged besides from being trimmed

if you supply a [trim] node, and its value is anything but 'true', the characters in 
your trim node will be removed from the beginning and the end of your string

if [what] is given, but has null or empty value, then string will be split for every single 
character in it.  if [where] is used, then the values of [where] is expected to be 
integers telling at which index the string should be split.  if you supply a [where] node, 
and it has no children nodes, then the value of [where] is expected to be an integer 
telling at which index you wish for the string to be split.  if you supply a [regex] node, 
then it will be treated as a regular expression, telling the engine what to look for to 
split the string

both [what], [where] and [regex] value or children node's values can be either constants, 
or expressions

if you use [what] to split your string, then the parts which matches the [what] expression 
in your string, will be removed from the result set

if you supply a [where] block where some of the indexes inside your where block are 
past the length of the string, then the string will be split into as many strings 
as is possible, and the remaning indexes in your [where] will simply be ignored.  each 
consecutive value of [where] must be higher than the previous value

thread safe"

magix.execute.split-sample
  _data=>@"  some text that will be split for every space, and trimmed for white space characters  "
  split=>[_data].value
    what=>@" "
    trim=>true
  _data2=>@"  will be trimmed only  "
  split=>[_data2].value
    trim=>true
  _data3=>@"XXwill be trimmed for all occurrencies of capital letter xXXX"
  split=>[_data3].value
    trim=>X
  _data4=>@"will be split at 10th index"
  split=>[_data4].value
    where=>10
  _data5=>@"will be split at 10th index and 15th index"
  split=>[_data5].value
    where
      =>10
      =>15
  _data6=>@"will be split where the '-- ' is found

-- 
Thomas Hansen"
  split=>[_data6].value
    regex=>@"\n-- *\n"


magix.execute.stop-dox=>@"stops the execution of the current scope

stops the execution of the current scope in the tree

affects [while], [for-each] and other code scopes, such as events and hyperlisp files 
executed using [execute-script]

thread safe"

magix.execute.stop-sample
  _data=(int)>5
  while=>more-than-equals
    lhs=>[_data].value
    rhs=>1
    code
      using=>magix.math
        add
          =>[_data].value
          =>-1
      set=>[_data].value
        value=>[@][using][add].value
      stop


magix.execute.switch-dox=>@"executes logic according to value of string

[switch] creates a comparison between all the children [case] nodes, and executes the code 
within the [case] node who's value equals the content of the [switch] node, if any

the [switch] node's value can be either a constant or an expression.  if no match is found, 
then [default] will be executed, if a [default] exist.  notice how both the [switch] node 
itself, and [case] nodes can be both expressions or constants

all [case] values must be unique

thread safe"

magix.execute.switch-sample
  _data=>3
  _success=>3
  switch=>[_data].value
    case=>1
      magix.viewport.show-message
        message=>ERROR!!
    case=>2
      magix.viewport.show-message
        message=>ERROR!!
    case=>[_success].value
      magix.viewport.show-message
        message=>success!
    default
      magix.viewport.show-message
        message=>ERROR!!


magix.execute.fork-dox=>@"spawns a new execution thread

spawns a new thread, which the given code block will be executed within

[fork] is useful for long operations, where you'd like to return to caller, before the operation is 
finished.  the entire node-list underneath the [fork] keyword, will be cloned, and passed into the 
magix.execute active event, for execution on a different thread

the forked thread will not be able to change any data on the original node set.  if the value of 
[fork] is true, the new thread will be executed as a fire-and-forget thread, bypassing any [wait] 
statements you might have

thread safe"

magix.execute.fork-sample
  fork
    _data
      value=>thomas
    if=>equals
      lhs=>[_data][value].value
      rhs=>thomas
      code
        _do-some-legthy
          _operation


magix.execute.wait-dox=>@"waits for multiple threads to finish

will wait for multiple treads to finish

all [fork] blocks created underneath [wait], will have to be finished, before the execution will 
leave the [wait] block.  you can optionally set a maximum number of milliseconds, before the wait 
is dismissed as an integer value of [wait]

when you create your threads with the [fork] statement inside a [wait], then when the wait is 
finished executing, the resulting code tree from all your [fork] statements will be copied 
into the original code tree.  this means that you can have fork statements modify the original 
code tree, returning their result back to the original code tree's main thread

you can only add [fork] statements beneath a [wait] statement

thread safe"

magix.execute.wait-sample
  wait=>10000
    fork
      _do-lenghty-job-1
    fork
      _do-lenghty-job-2


magix.execute.while-dox=>@"loops as long as condition is true

creates a loop that executes the underlaying code block repeatedly, as long as the 
comparison statement(s) in the value of [while] is true

the values compared must be given through [lhs] and [rhs], which means 
'left-hand-side' and 'right-hand-side', and the operator used to compare 
the [lhs] and the [rhs] nodes must be given using the value of the [while] 
node.  legal values for the operator is 'exist', 'not-exist', 'equals', 
'not-equals', 'less-than', 'more-than', 'less-than-equals', 
'more-than-equals', 'regex-match' and 'not-regex-match'

if you use 'regex-match' or 'not-regex-match' as your operator, then the 
regular expression you wish to use must be given in the [lhs] node, and 
the value or expression where you wish to find your match be given through 
the [rhs] node.  please notice that if you use regular expressions, then 
if your regular expression starts with a '[', it must be escaped by 
appending an '\' in front of it, otherwise the expression engine will 
think it is an expression leading to another node


[lhs] means 'left-hand-side'.  the lhs node is conceptually to the left 
of the operator.  [rhs] means 'right-hand-side', and is conceptually to 
the right of the operator.  this means that if you have an lhs value of 
'x' and an rhs value of 'y' and your operator is 'equals', then the 
full comparison statement becomes 'while x equals y'.  if you have an 
operator of 'more-than', and an [lhs] of 5 and an [rhs] of 4, then 
the full statement becomes 'while 5 is more-than 4', which of course 
will evaluate to true in a never ending loop.  both [lhs], [rhs] and 
the operator value of your [while] can be either constants or expressions

[lhs] and [rhs] can contain formatting expressions, such as {0} and {1},
de-referencing children nodes of [lhs] and [rhs]

depending upon the comparison operator you use, the [rhs] node might 
not be necessary.  for instance, 'exist' does not need a right-hand-side, 
or an rhs node, since it only checks for the existence of one specific 
node, value or name

you can optionally also supply as many [or] and/or [and] nodes beneath 
your [while] node.  if you do, then these are additional statements that 
needs to return true to make the [while] statement become true as a whole.  
if you supply an [or] and/or an [and] statement beneath your [while], then 
you must add up a comparison operator as the value of your [and] and [or] 
statements, and another pair of [lhs] and [rhs] nodes beneath your [and] 
and [or] statements

the engine will convert automatically between int, decimal, date and 
bool, or resort to string if no conversion is possible.  you can compare 
two node trees in [lhs] and [rhs], which means that the node trees will 
be compared deeply, comparing their name, value and children for equality

while executes immutable, meaning it will not modify its children 
nodes after it is done executing, and every iteration of the loop 
will execute on a 'virgin' version of the [code} block.  this means 
that the code it executes will be reset back to what it originally 
was for every single iteration of the loop

you can stop a [while] loop with the [stop] keyword

thread safe"

magix.execute.while-sample
  _data
    txt1=>hello world 1.0
    txt2=>hello world 2.0
    txt3=>hello world 3.0
  while=>not-equals
    lhs=>[_data].count
    rhs=>0
    code
      set=>[@][magix.viewport.show-message][message].value
        value=>[_data][0].value
      set=>[_data][0]
      magix.viewport.show-message


magix.execute.with-dox=>@"temporary changes the data pointer

temporary changes the data pointer to the expression in its value.  
[with] must have an expression returning an existing node list

this is useful if you're handling several keywords in a row, where 
the expressions within them are all pointing deep into the execution 
tree somewhere to shorten your expressions

thread safe"

magix.execute.with-sample
  _data
    _somewhere
      _over
        items
          message1=>howdy world 1.0
          message2=>howdy world 2.0
          message3=>howdy world 3.0
          message4=>howdy world 4.0
          message5=>howdy world 5.0
          message6=>howdy world 6.0
          message7=>howdy world 7.0
  with=>[_data][_somewhere][_over]
    for-each=>[items]
      set=>[@][magix.viewport.show-message][message].value
        value=>[.].value


magix.execute.sort-dox=>@"sorts a node list

executes the underlaying code block appending [_first] and [_second] being 
two nodes from the list of nodes pointed to by the value of [sort] itself

the code block inside of your sort, is expected to remove either [_first] or 
[_second] from its list of nodes, signaling which node comes before the other

if code block removes [_first], then [_second] is said to come before [_first].  
if code block removes [_second], then [_first] is said to come before [_second].  
if neither [_first] nor [_second] is removed by your sort implementation, then 
both nodes are said to be equal in sorting order"

magix.execute.sort-sample
  _data
    item1
      dec=(dec)>110000
    item2
      dec=(dec)>10000
    item3
      dec=(dec)>1006
    item4
      dec=(dec)>1000
    item5
      dec=(dec)>12000
  sort=>[_data]
    if=>less-than
      lhs=>[@][_first][0][dec].value
      rhs=>[@][_second][0][dec].value
      code
        set=>[@][..][..][_second]
    else-if=>more-than
      lhs=>[@][_first][0][dec].value
      rhs=>[@][_second][0][dec].value
      code
        set=>[@][..][..][_first]














