
<h2>hyper lisp expressions</h2>

<p>in hyper lisp, there doesn't exist the variables.&nbsp;&nbsp;this is because you're executing the execution tree 
directly, and hence everything is modifiable in hyper lisp.&nbsp;&nbsp;instead of having variables, you can just modify whatever 
node in the tree you wish.&nbsp;&nbsp;in hyper lisp, all nodes in the tree are potential data nodes, and hence everything 
is a variable</p>

<p>to de-reference a node, you must use expressions though.&nbsp;&nbsp;some hyper lisp keywords, allows for the use of 
expressions.&nbsp;&nbsp;an expression looks like the following</p>

<pre>
set=>[_data][v0].Value
  value=>5
</pre>

<p>above, the [set] statement contains an expression.&nbsp;&nbsp;what the above expression will do, is to de-reference a node 
called [v0], which it expects to find underneath the [_data] node.&nbsp;&nbsp;of course, this expression won't find that node, 
hence it will create it, since this is one of the features of the [set] statement.&nbsp;&nbsp;this way, you can create expressions 
which are "paths" to find specific nodes, and their values and names within your execution tree.&nbsp;&nbsp;the above code will 
create the followwing result</p>

<pre>
set=>[_data][v0].Value
  value=>5
_data
  v0=>5
</pre>

<p>imagine you have a deep data tree structure hierarchy, such as the one below</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>7
</pre>

<p>if you wish to access the [child-of-another] node's value, you'd have to create an expression similar to the one below</p>

<pre>
[_data][another-node][child-of-another].Value
</pre>

<p>to see a working piece of code, doing just that, imagine the following code</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>hello world
set=>[magix.viewport.show-message][message].Value
  value=>[_data][another-node][child-of-another].Value
</pre>

<p>the above code, will fetch the value of [child-of-another] node, and put it into a message box.&nbsp;&nbsp;if you have multiple 
nodes with the same name, you can reference them by index, such as below</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>hello world
  another-node
    child-of-another=>hello world 2
set=>[magix.viewport.show-message][message].Value
  value=>[_data][another-node:0][child-of-another].Value
set=>[magix.viewport.show-message:1][message].Value
  value=>[_data][another-node:1][child-of-another].Value
</pre>

<p>which will produce the following output</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>hello world
  another-node
    child-of-another=>hello world 2
set=>[magix.viewport.show-message][message].Value
  value=>[_data][another-node:0][child-of-another].Value
set=>[magix.viewport.show-message:1][message].Value
  value=>[_data][another-node:1][child-of-another].Value
magix.viewport.show-message
  message=>hello world
magix.viewport.show-message
  message=>hello world 2
</pre>

<p>you can also de-reference nodes by index alone, such as the code below</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>hello world 3
set=>[magix.viewport.show-message][message].Value
  value=>[0][1][0].Value
</pre>

<h3>searching for nodes in your execution tree</h3>

<p>you can de-reference nodes with a specific value, such as the code below</p>

<pre>
_data
  message=>msg1
    content=>hello world
  message=>msg2
    content=>hello world 2
set=>[magix.viewport.show-message][message].Value
  value=>[_data][message<strong>=>msg2</strong>][content].Value
</pre>

<p>the above code, will look for the [message] node containing the value of "msg2", and use the [content] of that node 
as the parameter to the message box, due to the <strong>"=&gt;"</strong> criteria in the [message=>msg2] parts of the expression</p>

<p>you can also do a wildcard search for nodes with undefined names, but where you know the value of the node.&nbsp;&nbsp;
this is done by using a question mark "?" as the name of the node, for then to optionally add a value beneath an => operator.
&nbsp;&nbsp;consider the following code</p>

<pre>
_data
  v0=>x
  v1=>
  v2
  v3=>y
set=>[magix.viewport.show-message:0][message].Value
  value=>[_data][?=>y].Name
set=>[magix.viewport.show-message:1][message].Value
  value=>[_data][?=>].Name
set=>[magix.viewport.show-message:2][message].Value
  value=>[_data][?].Name
</pre>

<p>the above will show a message box which contains v3 first, then v1 for then to show v2.&nbsp;&nbsp;this is because the 
first expression which is [_data][?=>y] will return the first child node of [_data] that has a value of "y".&nbsp;&nbsp;
then it will look for the first node which has an empty string as its value, because of [_data][?=>], for then to 
finally look for the first node which has a null value, because of the [_data][?] expression</p>

<h3>deep search through tree hierarchies</h3>

<p>in addition, you can perform a <em>"deep search"</em> through your node hierarchy, which will search for a node, matching a specific 
criteria.&nbsp;&nbsp;you can search for a node with a specific value, a specific name, or both using the "**" special operator in 
your expression.&nbsp;&nbsp;consider the following code</p>

<pre>
_buffer-data
  _data
    v0
      message=>wrong one
    v0=>hello
      message=>success! howdy world :)
set=>[magix.viewport.show-message][message].Value
  value=>[_buffer-data][<strong>**v0=>hello</strong>][message].Value
</pre>

<p>the above code will traverse through your entire tree, starting from [_buffer-data], looking for any node that has the name of 
<strong>v0</strong> and the value of <strong>hello</strong> and match it for the expression.&nbsp;&nbsp;this is useful for searching through 
deep tree hierarchies, where you don't know the exact position, or don't care.&nbsp;&nbsp;it is also useful for shortening 
expressions that would otherwise become much longer.&nbsp;&nbsp;both parts of the <strong>=&gt;</strong> parts of the expression 
are optional.&nbsp;&nbsp;if you ommit either parts of the =&gt; parts, it will match empty name/values.
&nbsp;&nbsp;consider the following</p>

<pre>
_buffer-data
  _data
    v0
      message=>wrong dude
    v0=>hello
      message=>too wrongs never make a wright
    v0=>
      message=>dude, correct!
set=>[magix.viewport.show-message][message].Value
  value=>[_buffer-data][<strong>**v0=></strong>][message].Value
</pre>

<p>the above code will match only the third child of [_data].&nbsp;&nbsp;if you ommit the =&gt; in its entirety, then it 
will match only a node who's value is null.&nbsp;&nbsp;consider the following code</p>

<pre>
_buffer-data
  _data
    v0=>
      message=>error
    v0=>hello
      message=>error 2.0
    v0
      message=>correctish!
set=>[magix.viewport.show-message][message].Value
  value=>[_buffer-data][<strong>**v0</strong>][message].Value
</pre>

<p>the above code will only match a node who's name is "v0" and who's value is null.&nbsp;&nbsp;the above code will show the 
message <em>"correctish!"</em>&nbsp;&nbsp;in addition, you can substitute any parts of the =&gt; operator with a question mark, 
signaling that you want to match any name/value.&nbsp;&nbsp;for instance, if you wish to search for a node who's value is "hello", 
and you don't care about its name, you would do something like the following</p>

<pre>
_buffer-data
  _data
    v0=>yo
      message=>error
    v0=>
      message=>error 2.0
    v0
      message=>crap
    v0=>hello
      message=>correctish!
set=>[magix.viewport.show-message][message].Value
  value=>[_buffer-data][<strong>**?=&gt;hello</strong>][message].Value
</pre>

<p>or if you wish to search for a node who's name you know, but who's value you don't know, you could do something like this</p>

<pre>
_buffer-data
  _data
    v0=>yo
      message-error=>error
    v0=>
      message-error=>error 2.0
    v0
      message-error=>crap
    v0=>hello
      message-success=>correctish!
set=>[magix.viewport.show-message][message].Value
  value=>[_buffer-data][<strong>**message-success=&gt;?</strong>].Value
</pre>

<p>notice how the wildcard operator "**" can traverse any depths of your tree, but that it starts it search from within where ever you 
put your wildcard operator in your expression.&nbsp;&nbsp;consider the following code</p>

<pre>
_data
  error=>search-query
    msg=>error
  _buffer
    jo
      hello
        somewhere
          over=>search-query
            msg=>success
set=>[magix.viewport.show-message][message].Value
  value=>[_data][_buffer][<strong>**?=>search-query</strong>][msg].Value
</pre>

<p>the wildcard operator will traverse your tree, looking for the first node that matches its criteria, regardless of how deep it 
needs to search.&nbsp;&nbsp;this feature is useful for shortening expressions that would otherwise becomes tediously long and difficult 
to follow.&nbsp;&nbsp;try changing the above code, and remove the [_buffer] parts of the expression in the [value] node of the [set], 
and see how it now will match the [error] node</p>

{{
lambda=>next
  oncreatecontrols
    magix.help.set-next
      next=>system42/admin/help/hyper-lisp/expression-operators.mml
}}
