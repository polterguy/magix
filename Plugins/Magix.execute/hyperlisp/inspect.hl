
inspect=>@"documentation for Magix.execute

contains the documentation for all active events in the 
Magix.execute assembly"


magix.execute.add-dox=>@"adds a node to another node

creates a deep copy of the node returned by the expression in the [value] node, and appends 
it into the expression found in [add].  if no [value] node is given, then all children of 
[add] will be added.  the [add] node must have en expression returning a node lists

if a [value] node is given, its value is an expression, and a [children-only] node exists, and 
its value is true, then only the children of the node returned by the expression in [value] 
will be added to the nodes found in the expression of [add].  if no [children-only] node exists, 
or its value is false, but a [value] node exists, with an expression returning a node list, then 
the entire node tree will be copied, with its children, including the node returned from [value] 
itself

if a [value] node exists, and it is a contant, or an expression returning anything but a node list, 
then a node with the name returned from the constant or expression of the [value] node will be 
added to the node list of the expression returned by [add].  in this case, one node will be added 
to the node list in the [add] expression, with the name of the [value] node's value.   if you supply 
a [value] node, who's value is not a node list, you can optionally also supply an additional [value] 
node as a child of the first [value] node, who's expression or constant value will become the value 
of the node added to the [add] node's collection

thread safe"

magix.execute.add-sample
  _copy
  _data
    children=>original
    children1=>will be copied
      item1=>will be copied too
      item2=>will also be copied
  add=>[_copy]
    value=>[_data]
    children-only=>true


magix.execute.node-2-code-dox=>@"transforms a node to text

will transform the [node] node to code syntax, and return it in [code].  [node] can either have 
its nodes as the value of the [node], as children nodes directly underneath the [node] node, or 
as an expression returned from the node node's value.  the code returned will be the textual 
representation of the original tree hierarchy with hyperlisp syntax.  two spaces ' ' opens up 
a child collection.  => separates name and value of node, name first

code returned might also contain type information for types of int, decimal, datetime and bool.  
if [remove-root] is true, then the root node will be removed, and not be a part of the code 
returned

thread safe"

magix.execute.node-2-code-sample
  node-2-code
    node
      some-node
        a-child=>howdy
        another-child=>hello
      another-node=>yo!


magix.execute.code-2-node-dox=>@"transforms hyperlisp text code to nodes

will transform the [code] node to a node tree

the code will be returned in [node] as a node structure, according to indentation.  two spaces 
opens up child collection, => assings to value, and first parts are name of node.  [code-2-node] 
also supports =(int)>, =(datetime)>, =(decimal)>> and =(bool)> to assign specific type to value.  
notice that you can instead of supplying a [code] node, supply a [file] node, which means the 
code will be loaded through the [magix.file.load] active event, instead of assumed to be found 
inline into the active event itself.  both [code] and [file] can be either constants or expressions

thread safe"

magix.execute.code-2-node-sample
  code-2-node
    code=>@"
code
  goes
    here"


magix.execute.debug-dox=>@"shows a debug dialog of the node stack

shows the entire stack of hyperlisp code in a modal message box.  
alternatively, you can submit an expression, pointing to a node list, 
to show only a subsection of the tree

not thread safe"

magix.execute.debug-sample
  magix.execute
    set=>[@][foo.bar].value
      value=>true
  debug=>[magix.execute]


magix.execute.application-startup-dox=>@"maps serialized active events

called during startup of application 
to make sure our active events, which are dynamically tied towards serialized hyper 
lisp blocks of code, are being correctly re-mapped"


magix.execute.event-dox=>@"creates a new active event

overrides the active event in [name] with the hyperlisp code in the [code] expression.  
these types of active events can take and return parameters.  if you wish to pass in or 
retrieve parameters, then as you invoke the function, just append your parameters 
underneath the function invocation, and they will be passed into the function, where 
they will be accessible underneath the [$] node, appended as the last parts of your code 
block, into your function invocation.  from outside of the active event itself, you can 
access these parameters directly underneath the active event itself

any existing event with the name from the [event] node's value will be deleted, if you 
pass in no [code] block.  if you set the [remotable] node to true, then the active event 
will be possible to invoke by remote servers, and marked as open.  if you set [persist] 
to false, then the active event will not be serialized into the data storage, meaning it 
will only last as long as the application is not restarted.  this is useful for active 
events whom are created for instance during the startup of your application, since it 
will save time, since they will anyway be overwritten the next time your application 
restarts

[name] can be either an expression, or a constant

thread safe"

magix.execute.event-sample
  event
    name=>foo.bar
    remotable=(bool)>False
    persist=(bool)>False
    code
      _data=>thomas
      _backup=>thomas
      if=>equals
        lhs=>[_data].value
        rhs=>[_backup].value
        code
          set=>[$][output].value
            value=>return-value
          set=>[/][magix.viewport.show-message][message].value
            value=>[$][input].value
      magix.viewport.show-message
  foo.bar
    input=>hello world 2.0
  event
    name=>foo.bar


magix.execute._active-event-2-code-callback-dox=>@"maps dynamic active events

maps dynamic active events towards their stored code.  is the main entry point for 
dynamically created active events, and will map the active event towards the actual 
code intended to be executed"


magix.execute._active-event-2-code-callback-dynamic-dox=>@"dynamically created active event

dynamically created active event, created with the [event] keyword.  
thread safety is dependent upon the active events raised internally 
within the active event"


magix.execute.session-event-dox=>@"creates a new active event for the current session

overrides the active event in [session-event] with the hyperlisp in the [code] expression 
for the current session.  name of active event is found as [name] node

these types of active events can take and return parameters.  if you wish to pass in or 
retrieve parameters, then as you invoke the function, just append your parameters 
underneath the function invocation, and they will be passed into the function, where they 
will be accessible underneath the [$] node, appended as the last parts of your code block, 
into your event invocation.  from outside of the active event itself, you can access these 
parameters directly underneath the active event itself

event will be deleted, if you pass in no [code] block.  note that a session event cannot 
be marked as neither open nor persisted

not thread safe"

magix.execute.session-event-sample
  session-event
    name=>foo.bar
    code
      _data=>thomas
      _backup=>thomas
      if=>equals
        lhs=>[_data].value
        rhs=>[_backup].value
        code
          set=>[$][output].value
            value=>return-value
          set=>[/][magix.viewport.show-message][message].value
            value=>[$][input].value
      magix.viewport.show-message
  foo.bar
    input=>hello world 2.0
  session-event
    name=>foo.bar


magix.execute.list-events-dox=>@"lists all active events in the system

returns all active events within the system.  add [all], [open], [remoted], 
[overridden] or [begins-with] to filter the events returned

active events are returned in [events].  list-events will not return unit 
tests and active events starting with '_' if [all] is false.  if [all], 
[open], [remoted] or [overridden] is defined, it will return all events 
fullfilling criteria, regardless of whether or not they are private events, 
tests or don't match the [begins-with] parameter

thread safe"

magix.execute.list-events-sample
  list-events
    begins-with=>magix.execute


magix.execute.try-dox=>@"creates a try block to handle exceptions

use the [try] keyword to create a block of [code], which will execute 
your [catch] execution block of code, if an exception is thrown, inside 
your [code] execution block

this exception handler will be invoked, even if an exception occurs any 
place underneath your try code block, deep within your logic.  you can 
handle exceptions being raised in sub-functions, recursively invoked 
active events, or natively thrown exceptions this way

if an exception is thrown, you can access the description of the 
exception in the [exception] node underneath your catch statement.  you 
can also add a [finally] piece of code block underneath the [try], which will 
always be executed, regardless of whether or not an exception was thrown

thread safe"

magix.execute.try-sample
  try
    code
      throw=>to try or not to try
      magix.viewport.show-message
        message=>crap, didn't work
    catch
      set=>[@][magix.viewport.show-message][message].value
        value=>[@][exception].value
      magix.viewport.show-message


magix.execute.throw-dox=>@"throws an exception

throws an exception, which will stop the entire current execution, and 
halt back to the previous catch, in the stack of active events.  [exception] 
in [catch] becomes the value of the [throw] node, or the exception message.  
use throw together with [try] to handle errors

thread safe"

magix.execute.throw-sample
  try
    code
      throw=>some exception error message
    catch
      set=>[@][magix.viewport.show-message][message].value
        value=>[@][exception].value
      magix.viewport.show-message


magix.execute.using-dox=>@"changes the default namespace

changes the default namespace for the current scope.  this allows you to raise 
active events which you normally would have to raise with a period in their 
name, without the period, which allows active events which normally cannot 
access the entire execution tree, to do just that

thread safe"

magix.execute.using-sample
  using=>magix.math
    add
      =(int)>4
      =(int)>1
  using=>magix.viewport
    show-message
      message=>[using][add].value


magix.execute.sandbox-dox=>@"restricts the active events possible to raise

changes the execution engine, making sure only keywords and active events within 
[whitelist] are legal keywords

this is a useful feature to prevent external sources, or untrusted scripts, to 
execute malicious code.  all keywords and active events which are not declared in 
the [whitelist] parameter, are illegal to executed as long as the instruction 
pointer is within the scope of the [code] block, which declares the block of code that 
is to be sandboxed

thread safe"

magix.execute.sandbox-sample
  sandbox
    whitelist
      foo
    code
      bar=>throws exception


magix.execute.execute-dox=>@"main hyperlisp execution entry point

executes the incoming parameters as hyperlisp, meaning it will raise everything 
containing a period, while everything not starting with a '_' will be assumed to 
be a hyperlisp keyword, and appended behind 'magix.execute.', before that string 
is raised as an active event

a hyperlisp keyword will have access to the entire data tree, while a normal active 
event will only be able to modify the parts of the tree from underneath its own node

active events are raised the way the appear sequentially beneath the magix.execute 
node

thread safe"

magix.execute.execute-sample
  _data
    value=>thomas
  execute
    if=>equals
      lhs=>[_data][value].value
      rhs=>thomas
      code
        magix.execute
          _data=>hi thomas
          using=>magix.viewport
            show-message
              message=>[_data].value
    else
      magix.viewport.show-message
        message=>hi stranger


magix.execute.for-each-dox=>@"iterates through a node list

loops through all the nodes in the given node-list expression, 
setting the data-pointer to the currently processed item

your code will execute once for every single node you have in 
your return expression.  use the [.] expression to de-reference 
the currently iterated node

for-each executes immutable, meaning it will not modify its child 
nodes after it is done executing, and every iteration of the loop 
will execute on a 'virgin' version of its code.  this means that 
the code it executes will be reset back to what it originally was 
for every single iteration of the loop

thread safe"

magix.execute.for-each-sample
  _data
    items
      message1=>howdy world 1.0
      message2=>howdy world 2.0
      message3=>howdy world 3.0
      message4=>howdy world 4.0
      message5=>howdy world 5.0
      message6=>howdy world 6.0
      message7=>howdy world 7.0
  for-each=>[_data][items]
    set=>[@][magix.viewport.show-message][message].value
      value=>[.].value


magix.execute.if-dox=>@"checks statement and executes code if true

executes the [code] block of nodes as an execution block, but only if 
the [if] statement returns true

pair your [if] statements together with [else-if] and [else] to create 
branching logic and control of flow within your program.  if an [if]
statement returns true, then no paired [else-if] or [else] statements 
will be executed

[lhs] means 'left-hand-side', and if you think of the operator, the 
lhs node is to the left of the operator.  [rhs] means 'right-hand-side', 
and is conceptually to the right of the operator.  this means that if you 
have an lhs value of 'x' and an rhs value of 'y' and your operator is 
'equals', then the full comparison statement becomes 'if x equals y'

the operator used to compare the [lhs] and the [rhs] nodes must be 
defined using the value of the [if] node.  legal values for the 
operator type is 'exist', 'not-exist', 'equals', 'not-equals', 
'less-than', 'more-than', 'less-than-equals' and 'more-than-equals'

depending upon the comparison operator you use, the rhs node is not 
necessary.  for instance, exist does not need a right-hand-side, or 
an rhs node, simply since it only checks for the existence of one 
specific node, value or name

you can optionally also supply as many [or] and/or [and] nodes beneath 
your [if] node.  if you do, then these are additional statements that 
needs to return true to make the if statement become true as a whole.  
if you supply an or and/or an and statement beneath your if, then you 
add up a comparison operator as the value of your and and if statement, 
and another pair of lhs and rhs nodes beneath your and and or statements

the engine will convert automatically between int, decimal, date and 
bool, or resort to string if no conversion is possible.  the [lhs] and 
[rhs] nodes can be either an expression, or a hardcoded value.  you can 
compare two node trees in [lhs] and [rhs], which means that the node trees will be compared 
deeply, comparing their name, value and children for equality

thread safe"

magix.execute.if-sample
  _data
    item=>cache-object
    cache
  if=>not-equals
    lhs=>[_data][item].value
    rhs=>[_data][1].name
    and=>not-exist
      lhs=>[_data].value
    code
      magix.viewport.show-message
        message=>not equal, and no _data value


magix.execute.else-if-dox=>@"checks statement and executes code if true

executes the [code] block of nodes as an execution block, but only if 
the [else-if] statement returns true, and any previous [if] or [else-if] 
have returned false

pair your [else-if] statements together with [if] and [else] to create 
branching logic and control of flow within your program.  if an [if]
statement returns true, then no paired [else-if] or [else] statements 
will be executed.  the else-if statement can only follow directly after 
an [if] statement, or another [else-if] statement

[lhs] means 'left-hand-side', and if you think of the operator, the 
lhs node is to the left of the operator.  [rhs] means 'right-hand-side', 
and is conceptually to the right of the operator.  this means that if you 
have an lhs value of 'x' and an rhs value of 'y' and your operator is 
'equals', then the full comparison statement becomes 'if x equals y'

the operator used to compare the [lhs] and the [rhs] nodes must be 
defined using the value of the [if] node.  legal values for the 
operator type is 'exist', 'not-exist', 'equals', 'not-equals', 
'less-than', 'more-than', 'less-than-equals' and 'more-than-equals'

depending upon the comparison operator you use, the rhs node is not 
necessary.  for instance, exist does not need a right-hand-side, or 
an rhs node, simply since it only checks for the existence of one 
specific node, value or name

you can optionally also supply as many [or] and/or [and] nodes beneath 
your [if] node.  if you do, then these are additional statements that 
needs to return true to make the if statement become true as a whole.  
if you supply an or and/or an and statement beneath your if, then you 
add up a comparison operator as the value of your and and if statement, 
and another pair of lhs and rhs nodes beneath your and and or statements

the engine will convert automatically between int, decimal, date and 
bool, or resort to string if no conversion is possible.  the [lhs] and 
[rhs] nodes can be either an expression, or a hardcoded value.  you can 
compare two node trees in [lhs] and [rhs], which means that the node trees will be compared 
deeply, comparing their name, value and children for equality

thread safe"

magix.execute.else-if-sample
  _data
    node
  if=>exist
    lhs=>[_data][node].value
    code
      magix.viewport.show-message
        message=>darn it
  else-if=>exist
    lhs=>[_data][node]
    code
      magix.viewport.show-message
        message=>puuh


magix.execute.else-dox=>@"default execution of if and else-if

executes the underlaying code block, but only if no paired [if] 
or [else-if] statement has returned true

thread safe"

magix.execute.else-sample
  if=>exist
    lhs=>[_not-existing-node]
    code
      magix.viewport.show-message
        message=>ohh crap
  else
    magix.viewport.show-message
      message=>yup, still sane


magix.execute.index-of-dox=>@"returns index of a string

returns the index of all occurences of the [what] constant 
or expression as nodes containing the integer value of where match 
was found underneath the [result] return node

thread safe"

magix.execute.index-of-sample
  _data=>this will return the position of all 'r' characters in string
  index-of=>[_data].value
    what=>r


magix.execute.iterate-dox=>@"iterates a node tree

loops through all the nodes in the given node-list expression, flattening 
the hierarchy, setting the data-pointer to the currently processed item

notice how this differs in regards to the [for-each] keyword.  the for-each 
only iterates over the children of the nodes referenced in its expression.  
while the [iterate] keyword will iterate the entire tree hierarchy, including 
all children of the nodes in the expression, their children, and their 
children's children, and so on.  this is useful for iterating entire tree 
hierarchies, basically treating a tree, like a list of items, flattening the 
hierarchy

your code will execute once for every single node you have in your return 
expression.  use the [.] expression to de-reference the currently iterated 
node

iterate executes immutable, meaning it will not modify its child 
nodes after it is done executing, and every iteration of the loop 
will execute on a 'virgin' version of its code.  this means that 
the code it executes will be reset back to what it originally was 
for every single iteration of the loop

thread safe"

magix.execute.iterate-sample
  _data
    items
      message1=>howdy world 1.0
      sub-1
        message2=>howdy world 2.0
        message3=>howdy world 3.0
      sub-2
        message4=>howdy world 4.0
        sub-3
          message5=>howdy world 5.0
      sub-3
        message6=>howdy world 6.0
      message7=>howdy world 7.0
  iterate=>[_data][items]
    if=>exist
      lhs=>[.].value
      code
        set=>[@][magix.viewport.show-message][message].value
          value=>[.].value


magix.execute.lambda-dox=>@"executes a piece of code

executes the expression in the [lambda] node creating a deep copy 
of the expression's nodes

[lambda] can be given parameters, which will be accessible in the 
lambda code through the [$] collection.  anything you return as [$] 
from inside the code being executed, will become directly accessible 
as children nodes, from outside of the lambda execution, after the 
execution is finished

thread safe"

magix.execute.lambda-sample
  _data
    set=>[$][output].value
      value=>{0} {1}
        v0=>[$][input].value
        v1=>hansen
  lambda=>[_data]
    input=>thomas


magix.execute.override-dox=>@"overrides an active event with another

overrides the given active event from the [name] node's value with 
the active event from the [with] node's value.  if no [with] is given, 
existing override is removed

if you supply a [persist] parameter, and sets its value to false, then 
the override will not be persisted, and will only last until the 
application pool is restarted.  this is useful sometimes, since it will 
execute much faster, especially for overides you will anyway re-run 
when application pool is restarted

thread safe"

magix.execute.override-sample
  override
    name=>namespace.foo
    with=>namespace.bar


magix.execute.app-startup-dox=>@"initialization of tunneled events

called during startup of application to make sure our active events, 
which are remotely overridden are being correctly re-mapped"


magix.execute.tunnel-dox=>@"overrides an active event to be invoked on another server

creates an external override towards the given [url] for the event found in [name].  
if you pass in a null value as a [url], or no [url] node, the tunneling is removed

make sure the other side has marked the active event as remotable.  once a method is 
'tunneled', it will no longer be raised locally, but every time the active event is 
raised internally within your server, it will be polymorphistically raised, on your 
[url] end-point server instead

if a [persist] parameter exists, and it has a value of false, then the tunnel will not 
be serialized into the data layer, which is useful for active events which anyway will 
be re-mapped when the application pool is restarted

both [name] and [url] can be either expressions or constants

thread safe"

magix.execute.tunnel-sample
  tunnel
    name=>magix.namespace.foo
    url=>http://127.0.0.1:8080


magix.execute.open-dox=>@"opens up an active event for remote invocation

allows the given [name] active event to be remotely invoked.  this means 
that other servers, can call your active event, on your server

you can create a server-api for web-services, by opening active events for 
being remotely invoked, and such connect servers together, either internally 
as a part of your server park, or by exposing functionality to other networks

if you set [persist] to false, then the active event will not be serialized into 
the data storage, meaning it will only last as long as the application is not 
restarted.  this is useful for active events whom are created for instance during 
the startup of your application, since it will save time, since they will anyway 
be overwritten the next time your application restarts

[name] can be either an expression or a constant

thread safe"

magix.execute.open-sample
  open
    name=>magix.namespace.foo


magix.execute.close-dox=>@"closes an existing open active event

closes the active event found in [name], such that it no longer 
can be remotely invoked from other servers

if you set [persist] to false, then the active event will not be 
serialized into the data storage, meaning it will only last as long 
as the application is not restarted.  this is useful for active 
events whom are created for instance during the startup of your 
application, since it will save time, since they will anyway be 
overwritten the next time your application restarts

[name] can be either an expression or a constant

thread safe"

magix.execute.close-sample
  close
    name=>magix.namespace.foo


magix.execute.remote-dox=>@"remotely invokes an active event

remotely invokes the active event from value on [remote] on the 
given [url], passing in all nodes in [pars] as parameters to your 
active event, returning any return values from event beneath [params]

this effectively raises an active event, except the event will be 
serialized over http, and invoked on another server, returning 
transparently back to the caller, as if it was invoked locally

both [url] and [name] can be either expressions or constants

thread safe"

magix.execute.remote-sample
  remote
    name=>magix.namespace.foo
    url=>http://127.0.0.1:8080
    params
      your-parameters-goes-here=>value of parameter


magix.execute.replace-dox=>@"replaces a string with another string

replaces the [what] value/expression with the [with] value/expression 
in the value of the [replace] node's expression

both [what] and [with] can be either constants or expressions.  [with] 
is optional, and if not given, the [what] parts of the value of 
[replace] will simply be removed.  the value of [replace] can be either 
a constant, or an expression.  both [what] and [with] can contain children 
nodes, which will serve as formatting expressions, possible to de-reference 
as {0}, {1} and so on

thread safe"

magix.execute.replace-sample
  _expression=>some value to be replaced
  replace=>[_expression].value
    what=>some
    with=>some other


magix.execute.execute-script-dox=>@"executes a piece of hyper lisp script

runs the hyperlisp script given in value of [script], putting all child 
nodes from underneath the [params] node into the [$] collection, accessible 
from inside the script, which again is able to return nodes through the [$] 
node, which will become children of the [params] node after execution

you can optionally supply a [file] parameter, which will be loaded through 
[magix.file.load], and executed.  if you supply a [file] parameter, you 
cannot supply a [script] parameter

both [file] and [script], can either be expressions, or constants

thread safe"

magix.execute.execute-script-sample
  execute-script
    params
      input=>hello world
    script=>@"
_data=>thomas
if=>equals
  lhs=>[_data].value
  rhs=>thomas
  code
    set=>[@][magix.viewport.show-message][message].value
      value=>[$][input].value
    magix.viewport.show-message
    set=>[$][output].value
      value=>dude's still thomas"


magix.execute.set-dox=>@"sets some node value, name or content

sets the given expression in the value of [set] to the value of 
expression, or constant, in [value] node

if you pass in no [value], the expression in value will be 
nullified.  meaning, if it's a node-list it will be emptied 
and the node removed.  if it's a value, the value will become 
null.  if it's a name, the name will be set to the empty string

the [value]'s value can be either a constant or an expression

the value of [set] must be an expression, unless it's a null 
value, at which point the result of the set will be put into 
the value of the [set] itself

you can set a value of a node to either a name, value of 
another node or a node-list.  you can set a node-list to 
another node-list, at which case the entire node will be 
exchanged with a deep copy of the node list return from 
[value].  you can set the name of a node to a string, 
either through a constant or an expression

you can also add up child nodes of the [value] node, 
which can be de-referenced as a string.format statement, 
such that {0} will be replaced with the value of the 
first child node from beneath [value], and {2} will be 
replaced with the value of the third child node from 
beneath the [value], and so on

if you try to set a node that does not exist, the node 
will be created, and added to the execution tree

thread safe"

magix.execute.set-sample
  _data
    children=>old value
  set=>[_data][children].value
    value=>new value


magix.execute.split-dox=>@"splits a string

splits the given expression or constant in the value of [split] according to the [what] 
content or [where] child nodes, and puts the result into the [result] return node as 
children nodes.  if you add a [trim] parameter, and set its value to true, then the 
string will be trimmed before it is split

if [what] is given, but has null or empty value, then string will be split for every single 
character in it.  if [where] is used, then either value of [where] is expected to be one 
integer telling at which index the string should be split, or a list of children nodes 
underneath the [where] containing indexes for where to split the string is expected

both [what] and [where] value or nodes can be either a constant, or expression(s)

if you use [what] to split your string, then the parts which matches the [what] expression 
in your string, will be removed from the result set

thread safe"

magix.execute.split-sample
  _data=>some text which will be split for every space
  split=>[_data].value
    what=>@" "


magix.execute.stop-dox=>@"stops the execution of the current scope

stops the execution of the current scope in the tree

affects [while], [for-each] and other code scopes, such as events and event handlers

thread safe"

magix.execute.stop-sample
  _data=(int)>5
  while=>more-than-equals
    lhs=>[_data].value
    rhs=>1
    code
      using=>magix.math
        add
          =>[_data].value
          =>-1
      set=>[_data].value
        value=>[@][using][add].value
      stop


magix.execute.switch-dox=>@"executes logic according to value of string

[switch] creates a comparison between all the children [case] nodes, and executes the code 
within the [case] node who's value equals the content of the [switch] node

the [switch] node's value can be either a constant or an expression.  if no match is found, 
then [default] will be executed, if it exist.  notice how both the [switch] node itself, 
and [case] nodes can be expressions

thread safe"

magix.execute.switch-sample
  _data=>3
  _success=>3
  switch=>[_data].value
    case=>1
      magix.viewport.show-message
        message=>ERROR!!
    case=>2
      magix.viewport.show-message
        message=>ERROR!!
    case=>[_success].value
      magix.viewport.show-message
        message=>success!
    default
      magix.viewport.show-message
        message=>ERROR!!


magix.execute.fork-dox=>@"spawns a new execution thread

spawns a new thread, which the given code block will be executed within

[fork] is useful for long operations, where you'd like to return to caller, before the operation is 
finished.  the entire node-list underneath the [fork] keyword, will be cloned, and passed into the 
magix.execute active event, for execution on a different thread

the forked thread will not be able to change any data on the original node set.  if the value of 
[fork] is true, the new thread will be executed as a fire-and-forget thread, bypassing any [wait] 
statements you might have

not thread safe"

magix.execute.fork-sample
  fork
    _data
      value=>thomas
    if=>equals
      lhs=>[_data][value].value
      rhs=>thomas
      code
        _do-some-legthy
          _operation


magix.execute.wait-dox=>@"waits for multiple threads to finish

will wait for multiple treads to finish

all [fork] blocks created underneath [wait], will have to be finished, before the execution will 
leave the [wait] block.  you can optionally set a maximum number of milliseconds, before the wait 
is dismissed as an integer value of [wait]

thread safe"

magix.execute.wait-sample
  wait=>10000
    fork
      _do-lenghty-job-1
    fork
      _do-lenghty-job-2


magix.execute.while-dox=>@"loops as long as condition is true

creates a loop that executes the underlaying code block repeatedly, as long as the 
comparison statement(s) in the value of [while] is true

the [while] is taking arguments similarly as both the [if] and [else-if].  see any of 
these active events to understand how to create a comparison statement(s) to check for 
in the while loop

while executes immutable, meaning it will not modify its child 
nodes after it is done executing, and every iteration of the loop 
will execute on a 'virgin' version of its code.  this means that 
the code it executes will be reset back to what it originally was 
for every single iteration of the loop

thread safe"

magix.execute.while-sample
  _data
    txt1=>hello world 1.0
    txt2=>hello world 2.0
    txt3=>hello world 3.0
  while=>not-equals
    lhs=>[_data].count
    rhs=>0
    code
      set=>[@][magix.viewport.show-message][message].value
        value=>[_data][0].value
      set=>[_data][0]
      magix.viewport.show-message
        message=>to be changed


magix.execute.with-dox=>@"temporary changes the data pointer

temporary changes the data pointer to the expression in its value

this is useful if you're handling several keywords in a row, where 
the expressions within them are all pointing deep into the execution 
tree somewhere

thread safe"

magix.execute.with-sample
  _data
    _somewhere
      _over
        items
          message1=>howdy world 1.0
          message2=>howdy world 2.0
          message3=>howdy world 3.0
          message4=>howdy world 4.0
          message5=>howdy world 5.0
          message6=>howdy world 6.0
          message7=>howdy world 7.0
  with=>[_data][_somewhere][_over]
    for-each=>[items]
      set=>[@][magix.viewport.show-message][message].value
        value=>[.].value


















