
<h2>hyper lisp expressions</h2>

<p>in hyper lisp, there doesn't exist the variables.&nbsp;&nbsp;this is because you're executing the execution tree 
directly, and hence everything is modifiable in hyper lisp.&nbsp;&nbsp;instead of having variables, you can just modify whatever 
node in the tree you wish.&nbsp;&nbsp;in hyper lisp, all nodes in the tree are potential data nodes, and hence everything 
is a variable</p>

<p>to de-reference a node, you must use expressions though.&nbsp;&nbsp;some hyper lisp keywords, allows for the use of 
expressions.&nbsp;&nbsp;an expression looks like the following</p>

<pre>
set=>[_data][v0].Value
  value=>5
</pre>

<p>above, the [set] statement contains an expression.&nbsp;&nbsp;what the above expression will do, is to de-reference a node 
called [v0], which it expects to find underneath the [_data] node.&nbsp;&nbsp;of course, this expression won't find that node, 
hence it will create it, since this is one of the features of the [set] statement.&nbsp;&nbsp;this way, you can create expressions 
which are "paths" to find specific nodes, and their values and names within your execution tree.&nbsp;&nbsp;the above code will 
create the followwing result</p>

<pre>
set=>[_data][v0].Value
  value=>5
_data
  v0=>5
</pre>

<p>imagine you have a deep data tree structure hierarchy, such as the one below</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>7
</pre>

<p>if you wish to access the [child-of-another] node's value, you'd have to create an expression similar to the one below</p>

<pre>
[_data][another-node][child-of-another].Value
</pre>

<p>to see a working piece of code, doing just that, imagine the following code</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>hello world
set=>[magix.viewport.show-message][message].Value
  value=>[_data][another-node][child-of-another].Value
</pre>

<p>the above code, will fetch the value of [child-of-another] node, and put it into a message box.&nbsp;&nbsp;if you have multiple 
nodes with the same name, you can reference them by index, such as below</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>hello world
  another-node
    child-of-another=>hello world 2
set=>[magix.viewport.show-message][message].Value
  value=>[_data][another-node:0][child-of-another].Value
set=>[magix.viewport.show-message:1][message].Value
  value=>[_data][another-node:1][child-of-another].Value
</pre>

<p>which will produce the following output</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>hello world
  another-node
    child-of-another=>hello world 2
set=>[magix.viewport.show-message][message].Value
  value=>[_data][another-node:0][child-of-another].Value
set=>[magix.viewport.show-message:1][message].Value
  value=>[_data][another-node:1][child-of-another].Value
magix.viewport.show-message
  message=>hello world
magix.viewport.show-message
  message=>hello world 2
</pre>

<p>you can also de-reference nodes by index alone, such as the code below</p>

<pre>
_data
  some-node
    child-1=>5
  another-node
    child-of-another=>hello world 3
set=>[magix.viewport.show-message][message].Value
  value=>[0][1][0].Value
</pre>

<p>or you can de-reference nodes with a specific value, such as the code below</p>

<pre>
_data
  message=>msg1
    content=>hello world
  message=>msg2
    content=>hello world 2
set=>[magix.viewport.show-message][message].Value
  value=>[_data][message<strong>=>msg2</strong>][content].Value
</pre>

<p>the above code, will look for the [message] node containing the value of "msg2", and use the [content] of that node 
as the parameter to the message box, due to the <strong>"=&gt;"</strong> criteria in the [message=>msg2] parts of the expression</p>

<p>you can also do a wildcard search for nodes with undefined names, but where you know the value of the node.&nbsp;&nbsp;
this is done by using a question mark "?" as the name of the node, for then to optionally add a value beneath an => operator.
&nbsp;&nbsp;consider the following code</p>

<pre>
_data
  v0=>x
  v1=>
  v2
  v3=>y
set=>[magix.viewport.show-message:0][message].Value
  value=>[_data][?=>y].Name
set=>[magix.viewport.show-message:1][message].Value
  value=>[_data][?=>].Name
set=>[magix.viewport.show-message:2][message].Value
  value=>[_data][?].Name
</pre>

<p>the above will show a message box which contains v3 first, then v1 for then to show v2.&nbsp;&nbsp;this is because the 
first expression which is [_data][?=>y] will return the first child node of [_data] that has a value of "y".&nbsp;&nbsp;
then it will look for the first node which has an empty string as its value, because of [_data][?=>], for then to 
finally look for the first node which has a null value, because of the [_data][?] expression</p>

{{
lambda=>next
  oncreatecontrols
    magix.help.set-next
      next=>system42\admin\help\hyper-lisp\expression-operators.mml
}}
